<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="1、进程的虚拟内存分区在**13.2节（虚拟地址空间的分区）中讲到了进程的虚拟内存分区**，如下所示：  1.1、用户态虚拟内存与内核态虚拟内存程序的虚拟内存主要分为用户态虚拟内存区和内核态虚拟内存区，比如对于一个32位程序，系统会给进程分配4GB的虚拟内存，默认情况下用户态虚拟内存占2GB，内核态虚拟内存占2GB。 一般程序的业务模块主要运行在用户态虚拟内存中，驱动相关的模块则可能运行在内核态虚">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2025/06/02/debug/%E4%BE%8B%E5%AD%90/%E3%80%8AWindows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B%E8%8B%A5%E5%B9%B2%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8%E5%88%86%E4%BA%AB/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1、进程的虚拟内存分区在**13.2节（虚拟地址空间的分区）中讲到了进程的虚拟内存分区**，如下所示：  1.1、用户态虚拟内存与内核态虚拟内存程序的虚拟内存主要分为用户态虚拟内存区和内核态虚拟内存区，比如对于一个32位程序，系统会给进程分配4GB的虚拟内存，默认情况下用户态虚拟内存占2GB，内核态虚拟内存占2GB。 一般程序的业务模块主要运行在用户态虚拟内存中，驱动相关的模块则可能运行在内核态虚">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202506022223711.png">
<meta property="og:image" content="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202506022224519.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/bada6ebe895240bf8f65e7c32e158ea4.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/blog_migrate/60136e98c9e7aa36e668ef37b8a742a3.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/blog_migrate/571ade4ce4337f789873a924df944136.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/blog_migrate/79ead2f1e701b449f1309ff38eefa9e4.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/blog_migrate/4ca27a6a6386f0ab56a89ae71dc7af08.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/blog_migrate/b392410ee9bc28d119582005ec4fcf44.png">
<meta property="article:published_time" content="2025-06-02T14:22:57.212Z">
<meta property="article:modified_time" content="2025-06-02T14:42:54.129Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202506022223711.png">


<link rel="canonical" href="http://example.com/2025/06/02/debug/%E4%BE%8B%E5%AD%90/%E3%80%8AWindows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B%E8%8B%A5%E5%B9%B2%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8%E5%88%86%E4%BA%AB/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2025/06/02/debug/%E4%BE%8B%E5%AD%90/%E3%80%8AWindows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B%E8%8B%A5%E5%B9%B2%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8%E5%88%86%E4%BA%AB/","path":"2025/06/02/debug/例子/《Windows核心编程》若干知识点实战应用分享/","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title> | Hexo</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA"><span class="nav-number">1.</span> <span class="nav-text">1、进程的虚拟内存分区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1%E3%80%81%E7%94%A8%E6%88%B7%E6%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%8E%E5%86%85%E6%A0%B8%E6%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">1.1.</span> <span class="nav-text">1.1、用户态虚拟内存与内核态虚拟内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2%E3%80%81%E5%B0%8F%E4%BA%8E0x10000%E7%9A%84%E5%B0%8F%E5%9C%B0%E5%9D%80%E5%86%85%E5%AD%98%E5%8C%BA"><span class="nav-number">1.2.</span> <span class="nav-text">1.2、小于0x10000的小地址内存区</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BF%9D%E5%AD%98%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84CONTEXT%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">2.</span> <span class="nav-text">2、保存线程上下文的CONTEXT结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E4%BB%8E%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E8%A7%92%E5%BA%A6%E5%8E%BB%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E7%9A%84%E5%85%B8%E5%9E%8B%E5%AE%9E%E4%BE%8B"><span class="nav-number">3.</span> <span class="nav-text">3、从汇编代码角度去理解多线程运行过程的典型实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E8%B0%83%E7%94%A8TerminateThread%E5%BC%BA%E5%88%B6%E7%BB%93%E6%9D%9F%E7%BA%BF%E7%A8%8B%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E6%B2%A1%E6%9C%89%E9%87%8A%E6%94%BE%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">4、调用TerminateThread强制结束线程会导致线程中的资源没有释放的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E8%B0%83%E7%94%A8WaitForSingleObject%E7%9B%91%E6%B5%8B%E7%9B%AE%E6%A0%87%E7%A8%8B%E5%BA%8F%E6%9C%89%E6%B2%A1%E6%9C%89%E9%80%80%E5%87%BA"><span class="nav-number">5.</span> <span class="nav-text">5、调用WaitForSingleObject监测目标程序有没有退出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1%E3%80%81WaitForSingleObject%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="nav-number">5.1.</span> <span class="nav-text">5.1、WaitForSingleObject函数说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2%E3%80%81%E8%B0%83%E7%94%A8WaitForSingleObject%E5%87%BD%E6%95%B0%E7%9B%91%E6%B5%8B%E7%BA%BF%E7%A8%8B%E6%88%96%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E5%B7%B2%E7%BB%8F%E9%80%80%E5%87%BA"><span class="nav-number">5.2.</span> <span class="nav-text">5.2、调用WaitForSingleObject函数监测线程或进程是否已经退出</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-1%E3%80%81%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%AE%9E%E6%97%B6%E7%9B%91%E6%B5%8B%E4%B8%BB%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E5%B7%B2%E7%BB%8F%E9%80%80%E5%87%BA%EF%BC%8C%E4%B8%BB%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E4%BA%86%EF%BC%8C%E5%88%99%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%A6%81%E8%87%AA%E5%8A%A8%E9%80%80%E5%87%BA"><span class="nav-number">5.2.1.</span> <span class="nav-text">5.2.1、子进程实时监测主进程是否已经退出，主进程退出了，则子进程要自动退出</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-2%E3%80%81%E5%90%AF%E5%8A%A8%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%90%8E%E7%AD%89%E5%BE%85%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%AE%8C%E9%80%80%E5%87%BA%E5%90%8E%EF%BC%8C%E5%86%8D%E6%89%A7%E8%A1%8C%E5%90%8E%E7%BB%AD%E6%93%8D%E4%BD%9C"><span class="nav-number">5.2.2.</span> <span class="nav-text">5.2.2、启动子进程后等待子进程执行完退出后，再执行后续操作</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/02/debug/%E4%BE%8B%E5%AD%90/%E3%80%8AWindows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B%E8%8B%A5%E5%B9%B2%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8%E5%88%86%E4%BA%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2025-06-02 22:22:57 / Modified: 22:42:54" itemprop="dateCreated datePublished" datetime="2025-06-02T22:22:57+08:00">2025-06-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h3 id="1、进程的虚拟内存分区"><a href="#1、进程的虚拟内存分区" class="headerlink" title="1、进程的虚拟内存分区"></a>1、进程的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">虚拟内存</a>分区</h3><p><strong>在**<strong>13.2节</strong></strong>（虚拟地址空间的分区）中讲到了进程的虚拟内存分区**，如下所示：</p>
<p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202506022223711.png" alt="image.png"></p>
<h4 id="1-1、用户态虚拟内存与内核态虚拟内存"><a href="#1-1、用户态虚拟内存与内核态虚拟内存" class="headerlink" title="1.1、用户态虚拟内存与内核态虚拟内存"></a>1.1、用户态虚拟内存与内核态虚拟内存</h4><p>程序的虚拟内存主要分为用户态虚拟内存区和内核态虚拟内存区，比如对于一个32位程序，系统会给进程分配4GB的虚拟内存，默认情况下用户态虚拟内存占2GB，内核态虚拟内存占2GB。</p>
<p>一般程序的业务模块主要运行在用户态虚拟内存中，驱动相关的模块则可能运行在内核态虚拟内存中。运行在用户态的模块禁止访问内核态内存地址，运行在内核态的模块禁止访问用户态虚拟内存。</p>
<blockquote>
<p>**在程序发生内存异常时，可能会出现用户态模块访问内核态内存地址的情况，会产生内存访问违例，程序发生崩溃。具体的表现为，发生崩溃的那条汇编指令中访问了一个很大的内核态内存地址，比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov     edx,dword ptr [eax]  ds:002b:fc8b7653=????????</span><br></pre></td></tr></table></figure>

<p>上述汇编指令中访问了一个很大的内存地址0xfc8b7653，对于32位程序来说，该地址属于内核态的内存地址。</p>
</blockquote>
<blockquote>
<p>**有人可能会说直接看C++代码就好了，为什么还要查看汇编呢？**因为程序发生崩溃时，最终是崩溃在某条汇编指令上，查看汇编代码能看出发生崩溃的最直接原因，比如指令中访问了不该访问的内存，例如访问了很小的内存（小地址内存区的内存）或者访问了很大的内存地址（内核态虚拟内存区的内存）。此外，一行代码可能由几个子句构成，通过查看汇编代码上下文，就能确定到底是哪个子句出的问题。 </p>
</blockquote>
<p>   对于32位程序，默认用户态虚拟内存占用2GB，如果程序中的业务模块庞大（需要占用大量的内存），而业务模块基本都运行在用户态虚拟内存中，默认的2GB的虚拟内存可能不够用，可以通过设置将用户态虚拟内存从2GB扩展到3GB。具体的做法是，<strong>在Visual Studio的工程属性中可以开启</strong><strong>&#x2F;LARGEADDRESSAWARE****启用大地址选项</strong>：（链接器 -&gt; 系统 -&gt; 启动大地址）<br>   <br><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202506022224519.png" alt="image.png"></p>
<p>这样用户态的虚拟内存就会从默认的2GB扩充到3GB，内核态内存也就变到了1GB。</p>
<p>   用户态虚拟内存达到上限，可能有两个原因：</p>
<blockquote>
<p><strong>1）程序中有内存泄漏，多次泄漏将内存耗尽了</strong><br>有内存泄漏的代码频繁地被执行，内存持续地被占用不释放，导致程序占用的虚拟内存接近或达到用户态虚拟内存的上限。对于这种情况，则要排查内存泄漏的点，彻底消除内存泄漏。<br><strong>2）程序中包含了多个业务模块，确实要占用大量的用户态内存</strong><br>程序中包含了多个业务模块，确实要占用大量的用户态虚拟内存。比如我们软件中使用WebRTC开源库，很庞大，初始化时会申请大量的内存（一上来很多业务就会将内存分配好），即启动时就会占用大量的内存。软件除了WebRTC库，还包含了多个业务模块，这样加起来占用的虚拟内存就更大了。</p>
</blockquote>
<p>对于这种情况，我们需要优化代码，减少程序对内存的占用。有一个重要的原则，需要使用时再去申请，不再使用时立即将内存释放掉。</p>
<p>   后来<strong>我们用Process Explorer工具观察软件在运行过程中占用的总虚拟内存大小（用户态的虚拟内存）：</strong></p>
<p><img src="https://i-blog.csdnimg.cn/direct/bada6ebe895240bf8f65e7c32e158ea4.png"></p>
<p>在崩溃时间点左右，程序的用户态内存已经接近32位程序默认的2GB的用户态虚拟内存的上限了（注意上图中不是当时的问题截图，只是一个查看程序虚拟内存占用的实例）。进一步排查，排除了内存泄漏的存在，是因为软件中的多个业务模块确实需要占用大量的内存空间。于是从上层到底层对内存占用进行了一些优化，虽然减少出问题的概率，但还是会出现闪退的问题。</p>
<p>   因为时间仓促，涉及到底层的多个模块，一时半会很难进行较大的优化。后来就开启了大地址选项，即将32位程序的2GB的用户态虚拟内存扩充了3GB，暂时将这个问题规避掉。经后续测试验证，确实有效地解决了问题。至于如何开启32位程序的大地址模式，<strong>只要在exe主程序的工程属性</strong>中开启&#x2F;LARGEADDRESSAWARE大地址选项即可：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/60136e98c9e7aa36e668ef37b8a742a3.png"></p>
<h4 id="1-2、小于0x10000的小地址内存区"><a href="#1-2、小于0x10000的小地址内存区" class="headerlink" title="1.2、小于0x10000的小地址内存区"></a>1.2、小于0x10000的小地址内存区</h4><p>       Windows系统专门预留了一块从0到0x10000的小地址内存区，又称空指针内存区或空指针赋值内存分区：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/571ade4ce4337f789873a924df944136.png"></p>
<p>专门为了帮程序员定位访问空指针的问题。</p>
<p>   当访问到这个内存区域时，就会触发内存访问违例，系统会强制将进程终止掉。为什么使用空指针就会访问到这个小地址内存区呢？比如类对象指针值为NULL，代码中没有判断指针是否为空，直接使用该指针去访问指向的类的成员变量，即将NULL值作为C++类对象的首地址，那么类对象的数据成员的内存地址就是相对于所在对象地址NULL的偏移，即成员变量的地址是个很小的内存地址，而访问变量的值就是去读或写该变量的内存地址中的内容，就是去访问变量的内存，这样就会去访问一个很小的内存地址，即访问空指针赋值区，就会触发内存访问违例，引发崩溃。</p>
<blockquote>
<p><strong>这里涉及了类对象中的成员变量内存在类对象中排布问题</strong>，成员变量的内存地址都是相对于所在类对象的内存地址的偏移！比如某案例中因为空指针访问了一个很小的内存地址（小地址内存区），产生内存访问违例发生崩溃，发生崩溃的那条汇编指令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov     edx,dword ptr [eax]  ds:002b:00000124=????????</span><br></pre></td></tr></table></figure>

<p>该汇编指令中访问的0x00000124，是个很小的内存地址，属于空指针内存区，是禁止访问的，所以产生了内存访问违例。</p>
</blockquote>
<blockquote>
<p>空指针是引发程序异常的常见原因之一。另外，访问已经释放内存的野指针，分析思路也是类似的，即类的成员变量的地址是相对所在类对象地址的偏移。</p>
</blockquote>
<p>   **这个地方有一点需要提一下，使用空指针去调用类的成员函数是否一定会导致崩溃呢？答案是不一定，不一定会导致崩溃，这主要看有没有访问不应该访问的内存。比如被调用函数中没有访问类的数据成员（成员变量，占用的是数据段内存），即不会访问类对象的内存，就不会崩溃。</p>
<blockquote>
<p>调用的函数执行的是代码段上的指令，调用函数本身并不会有异常。这里要区分数据段内存与代码段内存。</p>
</blockquote>
<p>但如果使用空指针去调用虚函数，会涉及到虚函数的二次寻址，即先去访问类对象中隐含的虚函数表指针中的内容（存放的虚函数表的首地址），虚函数表指针变量的地址就是其所属的C++类对象的首地址，就会因为空指针访问很小的内存地址，引发内存访问违例。</p>
<h3 id="2、保存线程上下文的CONTEXT结构体"><a href="#2、保存线程上下文的CONTEXT结构体" class="headerlink" title="2、保存线程上下文的CONTEXT结构体"></a>2、保存线程上下文的CONTEXT<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BB%93%E6%9E%84%E4%BD%93&spm=1001.2101.3001.7020">结构体</a></h3><p><strong>在**<strong>7.7节</strong></strong>（在实际上下文中谈CONTEXT结构体）中讲到了保存线程上下文信息的CONTEXT结构体。在多个线程之间切换时会使用到系统定义的CONTEXT结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Context Frame</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  This frame has a several purposes: 1) it is used as an argument to</span></span><br><span class="line"><span class="comment">//  NtContinue, 2) is is used to constuct a call frame for APC delivery,</span></span><br><span class="line"><span class="comment">//  and 3) it is used in the user level thread creation routines.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  The layout of the record conforms to a standard call frame.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CONTEXT</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The flags values within this flag control the contents of</span></span><br><span class="line">    <span class="comment">// a CONTEXT record.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If the context record is used as an input parameter, then</span></span><br><span class="line">    <span class="comment">// for each portion of the context record controlled by a flag</span></span><br><span class="line">    <span class="comment">// whose value is set, it is assumed that that portion of the</span></span><br><span class="line">    <span class="comment">// context record contains valid context. If the context record</span></span><br><span class="line">    <span class="comment">// is being used to modify a threads context, then only that</span></span><br><span class="line">    <span class="comment">// portion of the threads context will be modified.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If the context record is used as an IN OUT parameter to capture</span></span><br><span class="line">    <span class="comment">// the context of a thread, then only those portions of the thread&#x27;s</span></span><br><span class="line">    <span class="comment">// context corresponding to set flags will be returned.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The context record is never used as an OUT only parameter.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"> </span><br><span class="line">    DWORD ContextFlags;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This section is specified/returned if CONTEXT_DEBUG_REGISTERS is</span></span><br><span class="line">    <span class="comment">// set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT</span></span><br><span class="line">    <span class="comment">// included in CONTEXT_FULL.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"> </span><br><span class="line">    DWORD   Dr0;</span><br><span class="line">    DWORD   Dr1;</span><br><span class="line">    DWORD   Dr2;</span><br><span class="line">    DWORD   Dr3;</span><br><span class="line">    DWORD   Dr6;</span><br><span class="line">    DWORD   Dr7;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This section is specified/returned if the</span></span><br><span class="line">    <span class="comment">// ContextFlags word contians the flag CONTEXT_FLOATING_POINT.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"> </span><br><span class="line">    FLOATING_SAVE_AREA FloatSave;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This section is specified/returned if the</span></span><br><span class="line">    <span class="comment">// ContextFlags word contians the flag CONTEXT_SEGMENTS.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"> </span><br><span class="line">    DWORD   SegGs;</span><br><span class="line">    DWORD   SegFs;</span><br><span class="line">    DWORD   SegEs;</span><br><span class="line">    DWORD   SegDs;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This section is specified/returned if the</span></span><br><span class="line">    <span class="comment">// ContextFlags word contians the flag CONTEXT_INTEGER.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"> </span><br><span class="line">    DWORD   Edi;</span><br><span class="line">    DWORD   Esi;</span><br><span class="line">    DWORD   Ebx;</span><br><span class="line">    DWORD   Edx;</span><br><span class="line">    DWORD   Ecx;</span><br><span class="line">    DWORD   Eax;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This section is specified/returned if the</span></span><br><span class="line">    <span class="comment">// ContextFlags word contians the flag CONTEXT_CONTROL.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"> </span><br><span class="line">    DWORD   Ebp;</span><br><span class="line">    DWORD   Eip;</span><br><span class="line">    DWORD   SegCs;              <span class="comment">// MUST BE SANITIZED</span></span><br><span class="line">    DWORD   EFlags;             <span class="comment">// MUST BE SANITIZED</span></span><br><span class="line">    DWORD   Esp;</span><br><span class="line">    DWORD   SegSs;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This section is specified/returned if the ContextFlags word</span></span><br><span class="line">    <span class="comment">// contains the flag CONTEXT_EXTENDED_REGISTERS.</span></span><br><span class="line">    <span class="comment">// The format and contexts are processor specific</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"> </span><br><span class="line">    BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];</span><br><span class="line"> </span><br><span class="line">&#125; CONTEXT;</span><br></pre></td></tr></table></figure>


<p>线程是分配CPU时间片的基本单元，线程失去CPU时间片后，线程就会被挂起，进入了睡眠状态；线程获取到了CPU时间片，则会从睡眠中唤醒，继续执行。</p>
<p><strong>线程失去时间片时</strong>，会将线程上下文中的寄存器等信息保存到CONTEXT结构体中，然后进入挂起（睡眠）状态；<strong>当线程获取CPU时间片后</strong>，则会从之前保存的CONTEXT结构体中把之前保存的寄存器信息给读出来，放到当前的寄存器中，然后线程继续接着挂起前的状态继续运行。这点对于从汇编角度去理解多线程代码的执行细节很重要。</p>
<h3 id="3、从汇编代码角度去理解多线程运行过程的典型实例"><a href="#3、从汇编代码角度去理解多线程运行过程的典型实例" class="headerlink" title="3、从汇编代码角度去理解多线程运行过程的典型实例"></a>3、从汇编代码角度去理解多线程运行过程的典型实例</h3><p>在8.1节（原子访问:Interlocked 系列函数）中讲到的那个多线程实例，虽然很简单，但它是从汇编角度去理解多线程代码执行细节的典型实例。从汇编代码的角度才能将这个实例理解透彻的！</p>
<p>该例子中定义了一个long型的全局变量，然后创建了两个线程，线程函数分别是ThreadFunc1和ThreadFunc2，这两个线程函数中均对g_x变量进行自加操作（在访问共享变量g_x时未加锁同步），相关代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define a global variable</span></span><br><span class="line"><span class="type">long</span> g_x = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadFunc1</span><span class="params">(PVOID pvParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_x++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadFunc2</span><span class="params">(PVOID pvParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_x++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个问题，<strong>当这两个线程函数执行完后，全局变量g_x的值会是多少呢？一定会是2吗？</strong></p>
<p>   实际上，<strong>在两个线程函数执行完后，g_x的值不一定为2</strong>。这个实例需要从汇编代码的角度去理解，从C++源码看则很难搞懂，这是一个从汇编代码角度去理解代码执行细节的典型实例。</p>
<blockquote>
<p>熟悉汇编代码，不仅可以辅助排查C++软件异常，还可以理解很多高级语言无法理解的代码执行细节。</p>
</blockquote>
<p>   <em>有些人可能觉得，代码中就是一个自加的操作，一下子就执行完了，中间应该不会被打断。<strong>会不会被打断，其实要看汇编代码的</strong></em>，这行C++源码对应三行汇编代码，对g_x变量的自加这句C++代码，对应的汇编代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX, [g_x]  // 将g_x变量的值读到EAX寄存器中</span><br><span class="line">INC EAX         // 将EAX中的值执行自加操作</span><br><span class="line">MOV [g_x], EAX  // 然后将EAX中的值设置到g_x变量内存中</span><br></pre></td></tr></table></figure>

<p>看C++代码：g_x++，只能保证CPU执行某条<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4&spm=1001.2101.3001.7020">汇编指令</a>时不会被打断（汇编指令是CPU执行的最小粒度），但3条汇编指令，指令与指令之间是可能被打断的。</p>
<p>  为什么说两个线程执行完成后g_x变量的值是不确定的呢？比如可能存在两种场景：</p>
<p><strong>1）场景1（最终结果g_x&#x3D;2）</strong> </p>
<p>  假设线程1先快速执行了三行汇编指令，未被打断，g_x的值变成1。然后紧接着线程2执行，在g_x&#x3D;1的基础上累加，最终两个线程执行完后，g_x等于2。</p>
<p><strong>2）场景2（最终结果g_x&#x3D;1）</strong></p>
<p>  假设线程1先执行，当执行完前两条汇编指令后，线程1失去时间片（线程上下文信息保存到CONTEXT结构体中）：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/79ead2f1e701b449f1309ff38eefa9e4.png"></p>
<p>即线程1前两条汇编指令执行完，第3条汇编指令还没来得及执行，就失去CPU时间片了！</p>
<p>线程2执行，一次执行完三条指令，当前g_x&#x3D;1。然后线程1获得CPU时间片，因为上次执行两条汇编指令后EAX寄存器中的值为1，因为线程1获取了时间片，保存线程上下文信息的CONTEXT恢复到线程1中，EAX&#x3D;1，继续执行第3条指令，执行完后g_x还是1。</p>
<p><strong>所以，这个多线程问题，需要从汇编代码的角度去理解，从C++源码的角度很难想明白。</strong></p>
<p>从本例可以看出，即使是简单的变量自加操作，多线程操作时也要做同步，可以加锁，可以使用**<em>系统的原子锁Interlocked系列函数</em>**，比如原子自加函数InterlockedIncrement和原子自减函数InterlockedDecrement：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">InterlockedIncrement</span><span class="params">(  </span></span></span><br><span class="line"><span class="params"><span class="function">    LPLONG <span class="keyword">volatile</span> lpAddend   <span class="comment">// variable to increment</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">LONG <span class="title">InterlockedDecrement</span><span class="params">(  </span></span></span><br><span class="line"><span class="params"><span class="function">    LPLONG <span class="keyword">volatile</span> lpAddend   <span class="comment">// variable address</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这些原子函数能保证会被原子地被执行，中间不会被打断。 修改后的代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define a global variable</span></span><br><span class="line"><span class="type">long</span> g_x = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadFunc1</span><span class="params">(PVOID pvParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InterlockedIncrement（&amp;g_x）;  <span class="comment">// 调用原子锁函数InterlockedIncrement实现自加</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadFunc2</span><span class="params">(PVOID pvParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InterlockedIncrement（&amp;g_x）;  <span class="comment">// 调用原子锁函数InterlockedIncrement实现自加</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="4、调用TerminateThread强制结束线程会导致线程中的资源没有释放的问题"><a href="#4、调用TerminateThread强制结束线程会导致线程中的资源没有释放的问题" class="headerlink" title="4、调用TerminateThread强制结束线程会导致线程中的资源没有释放的问题"></a>4、调用TerminateThread强制结束线程会导致线程中的资源没有释放的问题</h3><p><strong>在**<strong>6.5节</strong></strong>（终止运行线程）中讲到了调用TerminateThread结束线程的相关问题。</p>
<p>创建线程时需要指定线程函数，当代码执行到线程函数中，线程才真正运行起来。线程函数执行完了，线程函数退出了，线程也就退出了。线程结束了，可能是线程函数自然执行完成了，也可能是人为地调用TerminateThread接口强制将进程退出了。</p>
<p>当线程函数自然地执行完退出时，函数中局部变量的栈内存会自动被释放，函数中的资源才会自动地被释放。如果线程函数执行的过程中被TerminateThread函数强行终止了，则会导致函数中的资源不会被释放，比如：</p>
<blockquote>
<p><strong>1）线程函数中局部变量的栈内存没有释放</strong><br>函数没有正常地执行完成，函数中局部变量占用的栈内存没有释放。<br><strong>2）线程函数中申请的资源没有释放</strong></p>
<p>比如线程函数中刚拿到一个锁，就被强行终止了，释放锁的代码没有执行到，导致线程结束了锁也没被释放掉。有次我们在用Windbg排查多线程死锁问题时，一个线程在申请锁，但通过查看锁信息得知该锁被另一个线程占用着，但我们查看进程的线程列表时并没有找到占用锁的那个线程id，估计线程已经结束了，可能就是因为该线程中途被Terminate掉了，还没将锁释放掉，线程就被终止了，所以出现了这个问题。</p>
</blockquote>
<p>此外，线程终止与进程终止是有区别的，线程被强行终止时系统不会去释放线程中的资源，但进程终止时系统会释放进程所有的资源。</p>
<h3 id="5、调用WaitForSingleObject监测目标程序有没有退出"><a href="#5、调用WaitForSingleObject监测目标程序有没有退出" class="headerlink" title="5、调用WaitForSingleObject监测目标程序有没有退出"></a>5、调用WaitForSingleObject监测目标程序有没有退出</h3><p><strong>在**<strong>4.4节</strong></strong>（子进程）中讲到了可以通过WaitForSingleObject监测目标程序有没有退出**。</p>
<h4 id="5-1、WaitForSingleObject函数说明"><a href="#5-1、WaitForSingleObject函数说明" class="headerlink" title="5.1、WaitForSingleObject函数说明"></a>5.1、WaitForSingleObject函数说明</h4><p>WaitForSingleObject 函数可以等待以下对象：</p>
<blockquote>
<ul>
<li>更改通知</li>
<li>控制台输入</li>
<li>可等待计时器</li>
<li>内存资源通知</li>
<li>事件（Event）</li>
<li>互斥量（Mutex）</li>
<li>信号量（Semaphore）</li>
<li>线程</li>
<li>进程</li>
</ul>
</blockquote>
<p>当等待对象从非触发状态变成触发状态（发出信号）， WaitForSingleObject就会返回；或者是等待时间超时，WaitForSingleObject也会返回。关于WaitForSingleObject的返回值如下所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4ca27a6a6386f0ab56a89ae71dc7af08.png"></p>
<p><strong>对于事件</strong>，分有信号和无信号两个状态，当事件对象编程有信号时，WaitForSingleObject立即返回。</p>
<p><strong>对于互斥量和信号量</strong>，调用WaitForSingleObject获取所有权，即WaitForSingleObject返回WAIT_OBJECT_0时获取他们的所有权，然后调用ReleaseMutex和ReleaseSemaphore释放对象的所有权。</p>
<p><strong>对于线程和进程</strong>，线程和进程创建时无信号，当线程和进程退出时对应的句柄就变成了有信号，这样WaitForSingleObject就返回了。可以通过WaitForSingleObject返回，判断线程或进程是否已经退出了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread, INFINITE); <span class="comment">// 参数INFINITE表示无限等待</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2、调用WaitForSingleObject函数监测线程或进程是否已经退出"><a href="#5-2、调用WaitForSingleObject函数监测线程或进程是否已经退出" class="headerlink" title="5.2、调用WaitForSingleObject函数监测线程或进程是否已经退出"></a>5.2、调用WaitForSingleObject函数监测线程或进程是否已经退出</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b392410ee9bc28d119582005ec4fcf44.png"></p>
<p>在主程序运行的过程中启动了一个子进程，有时主进程要等待子进程处理结果后根据返回的信息再控制后续代码的执行，有时子进程需要感知主进程是否已经退出，这两种情况都需要感知另一个进程是否已经退出。对于线程在某些场合下页存在类似的需求。</p>
<h5 id="5-2-1、子进程实时监测主进程是否已经退出，主进程退出了，则子进程要自动退出"><a href="#5-2-1、子进程实时监测主进程是否已经退出，主进程退出了，则子进程要自动退出" class="headerlink" title="5.2.1、子进程实时监测主进程是否已经退出，主进程退出了，则子进程要自动退出"></a>5.2.1、子进程实时监测主进程是否已经退出，主进程退出了，则子进程要自动退出</h5><p>主进程在运行过程中启动了一个子进程，启动子进程时将主进程的进程id传给子进程。子进程是依赖于主进程存活的，如果主进程退出或者崩溃了，则子进程就没有存在的意义了，要自动退出！所以子进程要实时监测主进程的状态，监测主进程有没有退出（包括崩溃闪退）。</p>
<p>可能有人会说，主进程可以在退出时通知子进程，子进程收到通知后再自行退出。<strong>但主进程可能会发生崩溃或闪退，这种情况下一般时没法通知子进程的。</strong></p>
<p>那子进程如何才能实时监测主进程是否退出了呢？不管是主进程正常退出，还是异常崩溃闪退，都要感知到。子进程可以启动一个子线程，在子线程中通过主进程传过来的主进程id，获取主进程句柄，然后调用WaitForSingleObject等待主进程退出，可以在子线程中无限等待。如果主进程一旦退出，WaitForSingleObject函数就会立即返回，这时子进程就可以调用ExitProcess等接口自行退出当前子进程了。</p>
<p>具体的代码实现是，子进程中启动一个子线程，将主进程传过来的主进程id传给该子线程，如下：（其中MonitorMainProcess是线程函数）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hThread = (HANDLE)_beginthreadex( <span class="literal">NULL</span>, <span class="number">0</span>, MonitorMainProcess, (<span class="type">void</span>*)dwMainProcessId, <span class="number">0</span>, <span class="literal">NULL</span> );</span><br><span class="line"><span class="keyword">if</span> ( hThread != <span class="literal">NULL</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CloseHandle</span>( hThread );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程函数MonitorMainProcess实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监控主工程</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> __stdcall <span class="title">MonitorMainProcess</span><span class="params">(<span class="type">void</span> * pParam )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD dwProcessId = (DWORD)pParam;</span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>( SYNCHRONIZE, FALSE, dwProcessId );</span><br><span class="line">    <span class="keyword">if</span>(hProcess == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ExitProcess</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 设置INFINITE无限等待</span></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>( hProcess, INFINITE );</span><br><span class="line">    <span class="built_in">CloseHandle</span>( hProcess );</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// WaitForSingleObject返回了，就表示主进程已经退出，直接退出本进程</span></span><br><span class="line">    <span class="built_in">ExitProcess</span>( <span class="number">-1</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>进程初始是无信号的，进程退出时就变成了有信号，这样WaitForSingleObject等待到信号后，就返回了，这样子进程就直到主进程退出了。</p>
<p>此处需要注意一下，调用OpenProcess时必须要设置SYNCHRONIZE参数，因为设置该标记参数后才能调用WaitForSingleObject去等待进程。微软MSDN上对SYNCHRONIZE如下：</p>
<blockquote>
<p><strong>SYNCHRONIZE</strong>：The right to use the object for synchronization. This enables a thread to wait until the object is in the signaled state.</p>
</blockquote>
<p>此外，监测主进程是否退出的代码是阻塞式的，不能放在主线程中的，这就是为什么要启动一个子线程去专门做这个监测任务的原因。</p>
<h5 id="5-2-2、启动子进程后等待子进程执行完退出后，再执行后续操作"><a href="#5-2-2、启动子进程后等待子进程执行完退出后，再执行后续操作" class="headerlink" title="5.2.2、启动子进程后等待子进程执行完退出后，再执行后续操作"></a>5.2.2、启动子进程后等待子进程执行完退出后，再执行后续操作</h5><p>有时我们需要启动一个子进程去完成某项操作，主进程在等待子进程的执行结果（需要获取子进程的执行数据）， 然后主进程再去执行后续操作。主进程在启动子进程后，就可以调用WaitForSingleObject等待子进程退出，比如如下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动一个子进程去执行一个操作任务</span></span><br><span class="line">STARTUPINFO s  = &#123;<span class="built_in">sizeof</span>(s)&#125;; </span><br><span class="line">PROCESS_INFORMATION   pi = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">CreateProcess</span>( <span class="literal">NULL</span>, cmdLine, <span class="literal">NULL</span>, <span class="literal">NULL</span>, TRUE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;s, &amp;pi ) )</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 等待进程执行完毕   </span></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>( pi.hProcess, INFINITE );   </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 关闭进程和主线程句柄</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>( pi.hProcess );   </span><br><span class="line">    <span class="built_in">CloseHandle</span>( pi.hThread );   </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">// ...  // 去拿子进程的执行结果，去执行后续操作</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有时启动一个子线程，要等子线程执行完退出后，根据处理结果信息去继续执行，和上面等待进程退出是类似的。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/05/26/debug/%E4%BE%8B%E5%AD%90/Windows%20UAC%E6%9D%83%E9%99%90%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8Awindbg%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/" rel="prev" title="">
                  <i class="fa fa-angle-left"></i> 
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/06/15/Obsidian%20%E5%A4%9A%E5%BA%93%E5%85%B1%E7%94%A8%E9%85%8D%E7%BD%AE/" rel="next" title="">
                   <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">John Doe</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
