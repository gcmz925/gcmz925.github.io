<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.2","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Gcmz Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Gcmz Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Gcmz">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Gcmz Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Gcmz Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Gcmz</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/07/Windows%20C++%20%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%20GNU%20gettext%20%E5%9B%BD%E9%99%85%E5%8C%96%E6%94%AF%E6%8C%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gcmz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gcmz Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Gcmz Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/07/Windows%20C++%20%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%20GNU%20gettext%20%E5%9B%BD%E9%99%85%E5%8C%96%E6%94%AF%E6%8C%81/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-07-07 00:24:31 / 修改时间：23:27:02" itemprop="dateCreated datePublished" datetime="2025-07-07T00:24:31+08:00">2025-07-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在 Linux 开发中，GNU <code>gettext</code> 是实现国际化（i18n）的经典方式，尤其适合 C&#x2F;C++ 项目。但在 Windows 上，<code>gettext</code> 没有官方提供的 MSVC 支持库。因此，我们需要手动构建所需库，并设置好项目环境。</p>
<p>这篇博客将详细介绍在 Windows + Visual Studio 下，通过手动编译 <code>gettext</code> 源码实现多语言支持的全过程，并额外介绍通过资源文件（.rc）实现多语言切换的另一种方式。</p>
<hr>
<h2 id="一、准备-gettext-开发环境"><a href="#一、准备-gettext-开发环境" class="headerlink" title="一、准备 gettext 开发环境"></a>一、准备 gettext 开发环境</h2><h3 id="1-1-下载与构建-gettext-for-Windows"><a href="#1-1-下载与构建-gettext-for-Windows" class="headerlink" title="1.1 下载与构建 gettext for Windows"></a>1.1 下载与构建 <code>gettext</code> for Windows</h3><p><code>GNU gettext-0.18.3.2</code> 是目前较新的版本，可以在 <a target="_blank" rel="noopener" href="http://www.gnu.org/software/gettext/">GNU 官网</a> 下载源码。但官方并未提供 Visual Studio (MSVC) 的预编译版本。</p>
<p>👉 推荐使用这个现成的 MSVC 工程模板：<a target="_blank" rel="noopener" href="https://github.com/gcmz925/gettext-msvc-2019">gettext-msvc-2019</a></p>
<p>克隆项目后，直接用 Visual Studio 打开 <code>.sln</code> 并编译，会生成两个库文件：</p>
<ul>
<li><p><code>libiconv.lib</code></p>
</li>
<li><p><code>libintl.lib</code></p>
</li>
</ul>
<p>生成后如下图所示：</p>
<p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202507072250947.png" alt="编译 libintl 和 libiconv"></p>
<hr>
<h3 id="1-2-创建你的工程并配置依赖"><a href="#1-2-创建你的工程并配置依赖" class="headerlink" title="1.2 创建你的工程并配置依赖"></a>1.2 创建你的工程并配置依赖</h3><p>新建一个 Visual Studio C++ 工程，配置如下：</p>
<ul>
<li><p>添加头文件路径：<code>gettext</code> 源码中的 <code>intl</code> 文件夹</p>
</li>
<li><p>添加 lib 目录：包含 <code>libiconv.lib</code> 和 <code>libintl.lib</code> 的路径</p>
</li>
<li><p>链接库：在 <code>链接器 -&gt; 输入 -&gt; 附加依赖项</code> 添加这两个库</p>
</li>
</ul>
<p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202507072253889.png" alt="配置项目属性"></p>
<hr>
<h3 id="1-3-示例代码"><a href="#1-3-示例代码" class="headerlink" title="1.3 示例代码"></a>1.3 示例代码</h3><p>创建 <code>main.c</code> 文件并写入以下内容：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libgnuintl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;E:\\Develop\\EveryDay\\20250706\\gettext-msvc\\Release-x64\\libiconv.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;E:\\Develop\\EveryDay\\20250706\\gettext-msvc\\Release-x64\\libintl.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _(STRING) gettext(STRING)  <span class="comment">// 宏用于简化翻译调用</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>); <span class="comment">// 自动读取 LANG 环境变量</span></span><br><span class="line">    <span class="built_in">bindtextdomain</span>(<span class="string">&quot;myapp&quot;</span>, <span class="string">&quot;./locale&quot;</span>);</span><br><span class="line">    <span class="built_in">textdomain</span>(<span class="string">&quot;myapp&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, _(<span class="string">&quot;Hello, World!&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, _(<span class="string">&quot;Goodbye!&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二、生成翻译文件"><a href="#二、生成翻译文件" class="headerlink" title="二、生成翻译文件"></a>二、生成翻译文件</h2><h3 id="2-1-使用-xgettext-提取文本"><a href="#2-1-使用-xgettext-提取文本" class="headerlink" title="2.1 使用 xgettext 提取文本"></a>2.1 使用 <code>xgettext</code> 提取文本</h3><p>执行以下命令从代码中提取需要翻译的字符串：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xgettext -k_ -o myapp.po main.c</span><br></pre></td></tr></table></figure>

<p>⚠️ 如果代码文件是 UTF-8 编码，记得添加编码参数，否则会报如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xgettext: Non-ASCII string at main.c:...</span><br><span class="line">Please specify the source encoding through --from-code.</span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xgettext --from-code=UTF-8 -k_ -o myapp.po main.c</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-编辑-po-文件"><a href="#2-2-编辑-po-文件" class="headerlink" title="2.2 编辑 .po 文件"></a>2.2 编辑 <code>.po</code> 文件</h3><p>在 <code>msgstr &quot;&quot;</code> 中填写翻译后的文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msgid &quot;Hello, World!&quot;</span><br><span class="line">msgstr &quot;你好，世界！&quot;</span><br><span class="line"></span><br><span class="line">msgid &quot;Goodbye!&quot;</span><br><span class="line">msgstr &quot;再见！&quot;</span><br></pre></td></tr></table></figure>

<p>示意图：</p>
<p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202507072317737.png" alt="编辑 po 文件"></p>
<hr>
<h3 id="2-3-编译-po-为-mo"><a href="#2-3-编译-po-为-mo" class="headerlink" title="2.3 编译 .po 为 .mo"></a>2.3 编译 <code>.po</code> 为 <code>.mo</code></h3><p>创建目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main.exe</span><br><span class="line">locale/</span><br><span class="line">└── zh_CN/</span><br><span class="line">    └── LC_MESSAGES/</span><br><span class="line">        └── myapp.po</span><br></pre></td></tr></table></figure>

<p>编译命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msgfmt -o ./locale/zh_CN/LC_MESSAGES/myapp.mo ./locale/zh_CN/LC_MESSAGES/myapp.po</span><br></pre></td></tr></table></figure>

<p>运行程序后，看到如下输出表示成功：</p>
<p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202507072320486.png" alt="翻译结果"></p>
<hr>
<h2 id="三、常见问题汇总"><a href="#三、常见问题汇总" class="headerlink" title="三、常见问题汇总"></a>三、常见问题汇总</h2><ol>
<li><p><strong>DLL 版本不一致</strong><br> 检查是否 64 位程序误用了 32 位的 DLL，或版本不匹配。</p>
</li>
<li><p><strong>编码错误</strong><br> Windows 上默认是 ANSI 编码，建议统一为 UTF-8，并用 <code>--from-code=UTF-8</code> 明确指定。</p>
</li>
<li><p><strong>环境变量 LANG 没设置</strong><br> 可以手动设置环境变量 <code>LANG=zh_CN</code> 来强制语言加载。</p>
</li>
</ol>
<hr>
<h2 id="四、替代方案：使用-rc-资源文件做多语言切换"><a href="#四、替代方案：使用-rc-资源文件做多语言切换" class="headerlink" title="四、替代方案：使用 .rc 资源文件做多语言切换"></a>四、替代方案：使用 <code>.rc</code> 资源文件做多语言切换</h2><p>除了 gettext，也可以通过 Windows 的资源文件 <code>.rc</code> 来支持多语言：</p>
<ul>
<li><p>为每种语言生成一个资源 DLL（带特定语言 ID）</p>
</li>
<li><p>主程序根据系统语言或用户设置加载对应的 DLL</p>
</li>
<li><p>通过 <code>LoadString()</code> 获取翻译文本</p>
</li>
</ul>
<p>👉 参考文章：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8989cb6727f0">用 .rc 文件做多语言</a></p>
<p>这种方式更加贴合 Windows 平台特性，但不够跨平台。若项目需兼容 Linux、macOS，推荐还是使用 gettext。</p>
<hr>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>虽然在 Windows 上使用 <code>gettext</code> 需要一些额外的配置与构建工作，但一旦搭建成功，多语言支持就变得非常轻松和规范。希望本文能帮你少踩坑，顺利完成 C++ 项目的国际化工作。</p>
<p>如有问题欢迎留言交流 👇</p>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/22/debug/%E4%BE%8B%E5%AD%90/PE%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gcmz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gcmz Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Gcmz Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/debug/%E4%BE%8B%E5%AD%90/PE%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-06-22 22:53:55 / 修改时间：23:14:52" itemprop="dateCreated datePublished" datetime="2025-06-22T22:53:55+08:00">2025-06-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>书接上文，接着来处理一下PE文件的导入表</p>
<h3 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h3><p>导入表位置和大小可以从PE文件头中<code>IMAGE_OPTIONAL_HEADER32</code>结构的<code>IMAGE_DATA_DIRECTORY</code>数据目录字段中获取，从<code>IMAGE_DATA_DIRECTORY</code>字段得到的是导入表的RVA值，如果在内存中查找导入表，那么将RVA值加上PE文件装入的基址就是实际的地址。</p>
<p>找到了数据目录结构，既能够找到导入表，导入表由一系列的<code>IMAGE_IMPORT_DESCRIPTOR</code>结构组成，结构的数量取决于程序需要使用的DLL文件数量，每个结构对应一个DLL文件，在所有结构的最后，由一个内容全为0的<code>IMAGE_IMPORT_DESCRIPTOR</code>结构作为结束标志，表结构定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD   Characteristics;</span><br><span class="line">        DWORD   OriginalFirstThunk;     <span class="comment">// 包含指向IMAGE_THUNK_DATA(输入名称表)结构的数组</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;              <span class="comment">// 当可执行文件不与被输入的DLL进行绑定时，此字段为0 </span></span><br><span class="line">    DWORD   ForwarderChain;             <span class="comment">// 第一个被转向的API的索引</span></span><br><span class="line">    DWORD   Name;                       <span class="comment">// 指向被输入的DLL的ASCII字符串的RVA</span></span><br><span class="line">    DWORD   FirstThunk;                 <span class="comment">// 指向输入地址表(IAT)的RVA</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>OriginalFirstThunk</code>和<code>FirstThunk</code>字段是相同的，他们都指向一个包含<code>IMAGE_THUNK_DATA</code>结构的数组，数组中每个<code>IMAGE_THUNK_DATA</code>结构定义了一个导入函数的具体信息，数组的最后以一个内容全为0的<code>IMAGE_THUNK_DATA</code>结构作为结束，该结构的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_THUNK_DATA32</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD ForwarderString;      <span class="comment">// PBYTE </span></span><br><span class="line">        DWORD Function;             <span class="comment">// PDWORD</span></span><br><span class="line">        DWORD Ordinal;</span><br><span class="line">        DWORD AddressOfData;        <span class="comment">// PIMAGE_IMPORT_BY_NAME</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>搜了下，这是一个双字共用体结构，当结构的最高位为1时，表示函数是以序号的方式导入的，这时双字的低位就是函数的序号，当双字最高位为0时，表示函数以函数名方式导入，这时双字的值是一个RVA，指向一个用来定义导入函数名称的<code>IMAGE_IMPORT_BY_NAME</code>结构，此结构定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_BY_NAME</span> &#123;</span><br><span class="line">    WORD    Hint;          <span class="comment">// 函数序号</span></span><br><span class="line">    CHAR   Name[<span class="number">1</span>];        <span class="comment">// 导入函数的名称</span></span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure>

<p>上面的所有结构就是导入表的全部，总结起来就是下图这张表。</p>
<p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202506222257114.png" alt="image.png"></p>
<p>现在我们来分析下上图，导入表中<code>IMAGE_IMPORT_DESCRIPTOR</code>结构的NAME字段指向字符串<code>Kernel32.dll</code>表明当前程序要从<code>Kernel32.dll</code>文件中导入函数，<code>OriginalFirstThunk</code>和<code>FirstThunk</code>字段指向两个同样的<code>IMAGE_THUNK_DATA</code>数组，由于要导入4个函数，所有数组中包含4个有效项目并以最后一个内容为0的项目作为结束。</p>
<p>第4个函数是以序号导入的，与其对应的<code>IMAGE_THUNK_DATA</code>结构最高位等于1，和函数的序号0010h组合起来的数值就是<code>80000010h</code>，其余的3个函数采用的是以函数名方式导入，所以<code>IMAGE_THUNK_DATA</code>结构的数值是一个RVA，分别指向3个<code>IMAGE_IMPORT_BY_NAME</code>结构，每个结构的第一个字段是函数的序号，后面就是函数的字符串名称了</p>
<p>上图为什么会出现两个一模一样的<code>IMAGE_THUNK_DATA</code>数组结构呢? 这是因为PE装载器会将其中一个结构修改为函数的地址<code>jmp dword ptr[xxxx]</code>其中的xxxx就是由<code>FirstThunk</code>字段指向的那个数组中的一员。</p>
<p>实际上当PE文件被装载入内存后，内存中的映像会被Windows修正为如下图所示的样子：</p>
<p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202506222300435.png" alt="image.png"></p>
<p>其中由<code>FristThunk</code>字段指向的那个数组中的每个双字都被替换成了真正的函数入口地址，之所以在PE文件中使用两份<code>IMAGE_THUNK_DATA</code>数组的拷贝并修改其中的一份，是为了最后还可以留下一份备份数据用来反过来查询地址所对应的导入函数名。</p>
<p>最后通过编程实现读取导入表数据（把之前欠的代码补上），先处理32位的，后续处理64的。<br>pe_analyzer.c</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Imagehlp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;Imagehlp.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function">HANDLE <span class="title">OpenPeByFileName</span><span class="params">(LPTSTR FileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hFile = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE hMapFile = <span class="literal">NULL</span>;</span><br><span class="line">    LPVOID lpMapAddress = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwFileSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    hFile = <span class="built_in">CreateFile</span>(FileName,</span><br><span class="line">        GENERIC_READ,</span><br><span class="line">        FILE_SHARE_READ,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        OPEN_EXISTING,</span><br><span class="line">        FILE_ATTRIBUTE_NORMAL,</span><br><span class="line">        <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to open file: %lu\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">goto</span> cleanup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dwFileSize = <span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (dwFileSize == INVALID_FILE_SIZE || dwFileSize == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid file size\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> cleanup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hMapFile = <span class="built_in">CreateFileMapping</span>(hFile,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        PAGE_READONLY,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        dwFileSize,</span><br><span class="line">        <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hMapFile == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateFileMapping failed: %lu\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">goto</span> cleanup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lpMapAddress = <span class="built_in">MapViewOfFile</span>(hMapFile,</span><br><span class="line">        FILE_MAP_READ,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        dwFileSize);</span><br><span class="line">    <span class="keyword">if</span> (lpMapAddress == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;MapViewOfFile failed: %lu\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">goto</span> cleanup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功时，先关闭句柄，映射仍然有效</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hMapFile);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lpMapAddress;</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hMapFile)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hMapFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hFile &amp;&amp; hFile != INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示DOS头信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisplayDOSHeadInfo</span><span class="params">(HANDLE ImageBase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIMAGE_DOS_HEADER pDosHead = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pDosHead = (PIMAGE_DOS_HEADER)ImageBase;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;DOS头：        %x\n&quot;</span>, pDosHead-&gt;e_magic);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件地址：     %x\n&quot;</span>, pDosHead-&gt;e_lfarlc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PE结构偏移：   %x\n&quot;</span>, pDosHead-&gt;e_lfanew);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是有效PE文件</span></span><br><span class="line"><span class="function">BOOL <span class="title">IsPEFile</span><span class="params">(HANDLE ImageBase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIMAGE_DOS_HEADER pDosHead = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_NT_HEADERS pNtHead = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ImageBase == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pDosHead = (PIMAGE_DOS_HEADER)ImageBase;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IMAGE_DOS_SIGNATURE != pDosHead-&gt;e_magic)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pNtHead = (PIMAGE_NT_HEADERS)((DWORD)pDosHead + pDosHead-&gt;e_lfanew);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IMAGE_NT_SIGNATURE != pNtHead-&gt;Signature)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取NT头指针</span></span><br><span class="line"><span class="function">PIMAGE_NT_HEADERS <span class="title">GetNtHead</span><span class="params">(HANDLE ImageBase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIMAGE_DOS_HEADER pDosHead = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_NT_HEADERS pNtHead = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pDosHead = (PIMAGE_DOS_HEADER)ImageBase;</span><br><span class="line">    pNtHead = (PIMAGE_NT_HEADERS)((DWORD)pDosHead + pDosHead-&gt;e_lfanew);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pNtHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示PE头中的文件头信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisplayFileHeaderInfo</span><span class="params">(HANDLE ImageBase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIMAGE_NT_HEADERS pNtHead = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_FILE_HEADER pFileHead = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pNtHead = <span class="built_in">GetNtHead</span>(ImageBase);</span><br><span class="line">    <span class="keyword">if</span> (!pNtHead)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pFileHead = &amp;pNtHead-&gt;FileHeader;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;运行平台:     %x\n&quot;</span>, pFileHead-&gt;Machine);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;节区数目:     %x\n&quot;</span>, pFileHead-&gt;NumberOfSections);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;时间标记:     %x\n&quot;</span>, pFileHead-&gt;TimeDateStamp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;可选头大小:   %x\n&quot;</span>, pFileHead-&gt;SizeOfOptionalHeader);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件特性:     %x\n&quot;</span>, pFileHead-&gt;Characteristics);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示PE头中的可选头信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisplayOptionalHeaderInfo</span><span class="params">(HANDLE ImageBase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIMAGE_NT_HEADERS pNtHead = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pNtHead = <span class="built_in">GetNtHead</span>(ImageBase);</span><br><span class="line">    <span class="keyword">if</span> (!pNtHead)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;入口点：        %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;镜像基址：      %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.ImageBase);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;镜像大小：      %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.SizeOfImage);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;代码基址：      %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.BaseOfCode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;区块对齐：      %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.SectionAlignment);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件块对齐：    %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.FileAlignment);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子系统：        %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.Subsystem);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;区段数目：      %x\n&quot;</span>, pNtHead-&gt;FileHeader.NumberOfSections);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;时间日期标志：  %x\n&quot;</span>, pNtHead-&gt;FileHeader.TimeDateStamp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;首部大小：      %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.SizeOfHeaders);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;特征值：        %x\n&quot;</span>, pNtHead-&gt;FileHeader.Characteristics);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;校验和：        %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.CheckSum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;可选头部大小：  %x\n&quot;</span>, pNtHead-&gt;FileHeader.SizeOfOptionalHeader);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;RVA 数及大小：  %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.NumberOfRvaAndSizes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示节区信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisplaySectionHeaderInfo</span><span class="params">(HANDLE ImageBase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIMAGE_NT_HEADERS pNtHead = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_FILE_HEADER pFileHead = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_SECTION_HEADER pSection = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD NumberOfSections = <span class="number">0</span>;</span><br><span class="line">    DWORD* difA = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD* difS = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pNtHead = <span class="built_in">GetNtHead</span>(ImageBase);</span><br><span class="line">    <span class="keyword">if</span> (!pNtHead)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pFileHead = &amp;pNtHead-&gt;FileHeader;</span><br><span class="line">    pSection = <span class="built_in">IMAGE_FIRST_SECTION</span>(pNtHead);</span><br><span class="line">    NumberOfSections = pFileHead-&gt;NumberOfSections;</span><br><span class="line"></span><br><span class="line">    difA = (DWORD*)<span class="built_in">malloc</span>(NumberOfSections * <span class="built_in">sizeof</span>(DWORD));</span><br><span class="line">    difS = (DWORD*)<span class="built_in">malloc</span>(NumberOfSections * <span class="built_in">sizeof</span>(DWORD));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!difA || !difS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(difA);</span><br><span class="line">        <span class="built_in">free</span>(difS);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;节区名称 相对偏移\t虚拟大小\tRaw数据指针\tRaw数据大小\t节区属性\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NumberOfSections; i++, pSection++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\t 0x%.8X \t 0x%.8X \t 0x%.8X \t 0x%.8X \t 0x%.8X\n&quot;</span>,</span><br><span class="line">            pSection-&gt;Name,</span><br><span class="line">            pSection-&gt;VirtualAddress,</span><br><span class="line">            pSection-&gt;Misc.VirtualSize,</span><br><span class="line">            pSection-&gt;PointerToRawData,</span><br><span class="line">            pSection-&gt;SizeOfRawData,</span><br><span class="line">            pSection-&gt;Characteristics);</span><br><span class="line"></span><br><span class="line">        difA[i] = pSection-&gt;VirtualAddress;</span><br><span class="line">        difS[i] = pSection-&gt;VirtualAddress - pSection-&gt;PointerToRawData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(difA);</span><br><span class="line">    <span class="built_in">free</span>(difS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将RVA转换为VA</span></span><br><span class="line"><span class="function">PVOID <span class="title">gcImageRvaToVa</span><span class="params">(PIMAGE_NT_HEADERS ntHeader, PVOID imageBase, DWORD rva, PIMAGE_SECTION_HEADER* SectionHeader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIMAGE_SECTION_HEADER section = <span class="built_in">IMAGE_FIRST_SECTION</span>(ntHeader);</span><br><span class="line">    DWORD sectionStart = <span class="number">0</span>;</span><br><span class="line">    DWORD sectionEnd = <span class="number">0</span>;</span><br><span class="line">    DWORD delta = <span class="number">0</span>;</span><br><span class="line">    DWORD ptr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ntHeader-&gt;FileHeader.NumberOfSections; i++, section++)</span><br><span class="line">    &#123;</span><br><span class="line">        sectionStart = section-&gt;VirtualAddress;</span><br><span class="line">        sectionEnd = sectionStart + <span class="built_in">max</span>(section-&gt;SizeOfRawData, section-&gt;Misc.VirtualSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rva &gt;= sectionStart &amp;&amp; rva &lt; sectionEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            delta = rva - sectionStart;</span><br><span class="line">            ptr = section-&gt;PointerToRawData + delta;</span><br><span class="line">            <span class="keyword">return</span> (PVOID)((BYTE*)imageBase + ptr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示导入表信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisplayImportTable</span><span class="params">(HANDLE ImageBase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIMAGE_DOS_HEADER pDosHead = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_NT_HEADERS pNtHead = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_IMPORT_DESCRIPTOR pInput = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_THUNK_DATA _pThunk = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwThunk = <span class="number">0</span>;</span><br><span class="line">    USHORT Hint = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* szFunction = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span>* szFunctionModule = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pDosHead = (PIMAGE_DOS_HEADER)ImageBase;</span><br><span class="line">    pNtHead = <span class="built_in">GetNtHead</span>(ImageBase);</span><br><span class="line">    <span class="keyword">if</span> (!pNtHead)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否存在导入表</span></span><br><span class="line">    <span class="keyword">if</span> (pNtHead-&gt;OptionalHeader.DataDirectory[<span class="number">1</span>].VirtualAddress == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取导入表地址</span></span><br><span class="line">    pInput = (PIMAGE_IMPORT_DESCRIPTOR)<span class="built_in">gcImageRvaToVa</span>(pNtHead, pDosHead, pNtHead-&gt;OptionalHeader.DataDirectory[<span class="number">1</span>].VirtualAddress, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; pInput-&gt;Name != <span class="literal">NULL</span>; pInput++)</span><br><span class="line">    &#123;</span><br><span class="line">        szFunctionModule = (PSTR)<span class="built_in">gcImageRvaToVa</span>(pNtHead, pDosHead, (ULONG)pInput-&gt;Name, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pInput-&gt;OriginalFirstThunk != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dwThunk = pInput-&gt;OriginalFirstThunk;</span><br><span class="line">            _pThunk = (PIMAGE_THUNK_DATA)<span class="built_in">gcImageRvaToVa</span>(pNtHead, pDosHead, dwThunk, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            dwThunk = pInput-&gt;FirstThunk;</span><br><span class="line">            _pThunk = (PIMAGE_THUNK_DATA)<span class="built_in">gcImageRvaToVa</span>(pNtHead, pDosHead, dwThunk, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; _pThunk-&gt;u<span class="number">1.</span>AddressOfData != <span class="literal">NULL</span>; _pThunk++)</span><br><span class="line">        &#123;</span><br><span class="line">            szFunction = (PSTR)<span class="built_in">gcImageRvaToVa</span>(pNtHead, pDosHead, (ULONG)(((PIMAGE_IMPORT_BY_NAME)_pThunk-&gt;u<span class="number">1.</span>AddressOfData)-&gt;Name), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (szFunction != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;Hint, szFunction - <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Hint = (USHORT)<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%0.4x\t%0.8x\t%s\t%s\n&quot;</span>, Hint, dwThunk, szFunctionModule, szFunction);</span><br><span class="line"></span><br><span class="line">            dwThunk += <span class="built_in">sizeof</span>(ULONG_PTR);  <span class="comment">// 32位系统是4，64位系统是8</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE lpMapAddress = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    lpMapAddress = <span class="built_in">OpenPeByFileName</span>(<span class="string">L&quot;E://Develop//Project//WinKernelProgram//99.st//PeHead//PE//Debug//PE.exe&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (lpMapAddress == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to open PE file.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IMAGE_DOS_HEADER sizeof :%d\n&quot;</span>, <span class="built_in">sizeof</span>(IMAGE_DOS_HEADER));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IMAGE_FILE_HEADER sizeof :%d\n&quot;</span>, <span class="built_in">sizeof</span>(IMAGE_FILE_HEADER));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IMAGE_OPTIONAL_HEADER32 sizeof :%d\n&quot;</span>, <span class="built_in">sizeof</span>(IMAGE_OPTIONAL_HEADER32));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsPEFile</span>(lpMapAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not a valid PE file.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">UnmapViewOfFile</span>(lpMapAddress);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DisplayDOSHeadInfo</span>(lpMapAddress);</span><br><span class="line">    <span class="built_in">DisplayFileHeaderInfo</span>(lpMapAddress);</span><br><span class="line">    <span class="built_in">DisplayOptionalHeaderInfo</span>(lpMapAddress);</span><br><span class="line">    <span class="built_in">DisplaySectionHeaderInfo</span>(lpMapAddress);</span><br><span class="line">    <span class="built_in">DisplayImportTable</span>(lpMapAddress);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UnmapViewOfFile</span>(lpMapAddress);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>pe_analyzer.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PE_ANALYZER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PE_ANALYZER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Imagehlp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开指定路径的 PE 文件并返回映射后的内存地址</span></span><br><span class="line"><span class="function">HANDLE <span class="title">OpenPeByFileName</span><span class="params">(LPTSTR FileName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断映射地址是否是合法 PE 文件</span></span><br><span class="line"><span class="function">BOOL <span class="title">IsPEFile</span><span class="params">(HANDLE ImageBase)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 PE 映射中的 NT 头地址</span></span><br><span class="line"><span class="function">PIMAGE_NT_HEADERS <span class="title">GetNtHead</span><span class="params">(HANDLE ImageBase)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 DOS 头信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisplayDOSHeadInfo</span><span class="params">(HANDLE ImageBase)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印文件头（IMAGE_FILE_HEADER）信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisplayFileHeaderInfo</span><span class="params">(HANDLE ImageBase)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印可选头（IMAGE_OPTIONAL_HEADER）信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisplayOptionalHeaderInfo</span><span class="params">(HANDLE ImageBase)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印节区表信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisplaySectionHeaderInfo</span><span class="params">(HANDLE ImageBase)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 RVA 转换为实际内存地址（VA）</span></span><br><span class="line"><span class="function">PVOID <span class="title">gcImageRvaToVa</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PIMAGE_NT_HEADERS ntHeader,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID imageBase,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD rva,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIMAGE_SECTION_HEADER* SectionHeader</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印导入表信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisplayImportTable</span><span class="params">(HANDLE ImageBase)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// PE_ANALYZER_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/15/debug/%E4%BE%8B%E5%AD%90/%E3%80%8AWindows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B%E8%8B%A5%E5%B9%B2%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8%E5%88%86%E4%BA%AB2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gcmz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gcmz Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Gcmz Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/15/debug/%E4%BE%8B%E5%AD%90/%E3%80%8AWindows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B%E8%8B%A5%E5%B9%B2%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8%E5%88%86%E4%BA%AB2/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-06-15 22:00:28 / 修改时间：22:05:11" itemprop="dateCreated datePublished" datetime="2025-06-15T22:00:28+08:00">2025-06-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="6、死锁检测工具LockCop"><a href="#6、死锁检测工具LockCop" class="headerlink" title="6、死锁检测工具LockCop"></a>6、死锁检测工具LockCop</h3><p><strong>在**<strong>9.8.6节</strong></strong>（使用等待链遍历API来检测死锁）中讲到了死锁检测工具LockCop**，使用该工具可以检测程序中是否存在多线程死锁：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/dce9475b87ff2c28a7a0e89dede9cbf0.png"></p>
<p>该工具是调用系统WCT （Wait Chain Traversal，等待链遍历）API函数GetThreadWaitChain来判断目标线程是否发生了死锁，但是只能监测关键代码段、互斥量等引发的死锁，如下所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b6789fe87885ec897de25381bda4ef8c.png"></p>
<p>所以在使用LockCop工具应该注意：</p>
<blockquote>
<p>1）该工具因为调用的API是Vista以上系统才提供的，所以不支持XP系统。<br>2）该工具只能检测临界区死锁和互斥量死锁，事件、信号量等引发的死锁是没法监测到的。<br>3）该工具检测不到WaitForMultipleObjects引发的死锁。</p>
</blockquote>
<h3 id="7、如何以管理员权限启动一个进程？"><a href="#7、如何以管理员权限启动一个进程？" class="headerlink" title="7、如何以管理员权限启动一个进程？"></a>7、如何以管理员权限启动一个进程？</h3><p><strong>在**<strong>4.5.1节</strong></strong>（自动提升进程的权限）讲到了如果以管理员权限启动一个进程。**</p>
<p>在Win7及以上系统中，如果系统UAC开关打开，且当前系统登录用户不是超级管理员Administrator用户，如果程序设置了以管理员权限运行，则在程序启动时系统会弹出UAC提示框，如下所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5bf44d7f35e93d0c13fd99674d63d03c.png"></p>
<p>提示用户软件可能会对机器进行更改（以管理员权限运行的程序可以修改系统关键路径中的文件或注册表等）。所以有些软件为了避免系统频繁地弹出UAC提示框，故意将程序设置以标准用户权限运行，比如我们研究过QQ，它默认就是以标准用户权限运行的。</p>
<p>在以标准用户权限运行的进程中，如果要启动一个子进程，则默认情况下子进程是继承父进程的权限，即以标准用户权限运行。但有些场景下，我们需要在以标准用户权限运行的进程中启动一个以管理员权限运行的子进程，比如执行软件的升级更新时，升级程序需要写注册表（向HKEY_LOCAL_MACHINE注册表下写入信息，需要管理员权限；向当前用户的HKEY_CURRENT_USER路径下写入信息，则不需要管理员权限）、需要向系统关键路径拷贝文件，需要有管理员权限才能执行，所以被启动起来的升级程序需要以管理员权限启动运行。</p>
<p>那如何在一个以标准用户权限运行的进程中，去启动一个以管理员权限运行的程序呢？其实很简单，调用系统API接口SheeExecuteEx，传入runas参数即可，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">SHELLEXECUTEINFO si;</span><br><span class="line"><span class="built_in">RtlZeroMemory</span>( &amp;si, <span class="built_in">sizeof</span>( SHELLEXECUTEINFO ) );</span><br><span class="line">si.cbSize = <span class="built_in">sizeof</span>(SHELLEXECUTEINFO);</span><br><span class="line">si.lpFile = _T(<span class="string">&quot;D:\\test.exe&quot;</span>);</span><br><span class="line"><span class="comment">//si.lpParameters = lpCmdParam;</span></span><br><span class="line">si.nShow = SW_SHOWNORMAL;</span><br><span class="line">si.lpVerb = _T(<span class="string">&quot;runas&quot;</span>);</span><br><span class="line">BOOL bRet = <span class="built_in">ShellExecuteEx</span>( &amp;si );</span><br><span class="line"><span class="keyword">if</span> ( !bRet ) <span class="comment">// 程序启动失败</span></span><br><span class="line">&#123;</span><br><span class="line">    TCHAR achLog[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 先取lasterror值</span></span><br><span class="line">    DWORD dwLastErr = <span class="built_in">GetLastError</span>();</span><br><span class="line">    _stprintf( achLog, _T(<span class="string">&quot;ShellExecuteEx failed, GetLastError: %d.&quot;</span>), dwLastErr );</span><br><span class="line">    <span class="built_in">WriteLog</span>( achLog );</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 再取hInstApp错误代码</span></span><br><span class="line">    <span class="type">int</span> nHInsVal = (<span class="type">int</span>)si.hInstApp;</span><br><span class="line">    <span class="keyword">if</span> ( nHInsVal &lt;= <span class="number">32</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        _stprintf( achLog, _T(<span class="string">&quot;ShellExecuteEx failure, errcode: %d.&quot;</span>), nHInsVal );</span><br><span class="line">        <span class="built_in">WriteLog</span>( achLog );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="8、如何判断程序是否以管理员权限运行？"><a href="#8、如何判断程序是否以管理员权限运行？" class="headerlink" title="8、如何判断程序是否以管理员权限运行？"></a>8、如何判断程序是否以管理员权限运行？</h3><p>有时我们需要判断进程是否以管理员权限运行，比如在运行安装包时需要安装包进程以管理员权限运行，因为安装包将执行写注册表、注册组件等需要管理员权限的操作。如果没有申请到管理员权限，这些需要管理员权限的操作都会执行失败，则会导致安装失败。以QQ7.1安装包为例，如果当前以标准用户登录到系统中，并且UAC关闭，双击运行时将申请不到管理员权限，QQ会弹出如下的提示框：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5b1027ff85f08b9b62ded3189194bd4f.png"></p>
<p>我们的安装程序可以参考QQ的做法，避免出现没有管理员权限导致安装失败的问题，即如果没有申请到管理员权限，则直接弹出如上类似的提示。要弹出提示，则要判断当前安装程序的进程是否以管理员权限运行。那应该如何判断呢？相关示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1、通过进程id获取进程句柄</span></span><br><span class="line">DWORD dwPid = <span class="number">2337</span>; <span class="comment">// 目标进程的进程id</span></span><br><span class="line">HANDLE hProcess = ::<span class="built_in">OpenProcess</span>( <span class="comment">/*PROCESS_ALL_ACCESS*/</span>PROCESS_QUERY_INFORMATION, FALSE, dwPid );</span><br><span class="line"><span class="keyword">if</span> ( hProcess == <span class="literal">NULL</span> )</span><br><span class="line">&#123;</span><br><span class="line">strTip.<span class="built_in">Format</span>( _T(<span class="string">&quot;OpenProcess to get the process handle failed, possible reason: the process id doesn&#x27;t exsit, GetLastError: %d&quot;</span>), <span class="built_in">GetLastError</span>() );</span><br><span class="line"><span class="built_in">AfxMessageBox</span>( strTip );</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2、调用IsRunasAdmin函数判断目标进程是否已管理员权限运行</span></span><br><span class="line">BOOL bRunAsAdmin = <span class="built_in">IsRunasAdmin</span>( hProcess );</span><br><span class="line"><span class="keyword">if</span> ( bRunAsAdmin )</span><br><span class="line">&#123;</span><br><span class="line">    strTip.<span class="built_in">Format</span>( _T(<span class="string">&quot;Pid(%d) run as admin!&quot;</span>), dwPid );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    strTip.<span class="built_in">Format</span>( _T(<span class="string">&quot;Pid(%d) don&#x27;t run as admin!&quot;</span>), dwPid );</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">AfxMessageBox</span>( strTip );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3、判断进程是否已管理员权限运行的函数实现</span></span><br><span class="line"><span class="function">BOOL <span class="title">IsRunasAdmin</span><span class="params">( HANDLE hProcess )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL bElevated = FALSE;  </span><br><span class="line">    HANDLE hToken = <span class="literal">NULL</span>;  </span><br><span class="line"> </span><br><span class="line">    CString strTip;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Get target process token</span></span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">OpenProcessToken</span>( hProcess<span class="comment">/*GetCurrentProcess()*/</span>, TOKEN_QUERY, &amp;hToken ) )</span><br><span class="line">    &#123;</span><br><span class="line">        strTip.<span class="built_in">Format</span>( _T(<span class="string">&quot;OpenProcessToken failed, GetLastError: %d&quot;</span>), <span class="built_in">GetLastError</span>() );</span><br><span class="line">        <span class="built_in">AfxMessageBox</span>( strTip );</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    TOKEN_ELEVATION tokenEle;</span><br><span class="line">    DWORD dwRetLen = <span class="number">0</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Retrieve token elevation information</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">GetTokenInformation</span>( hToken, TokenElevation, &amp;tokenEle, <span class="built_in">sizeof</span>(tokenEle), &amp;dwRetLen ) )</span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> ( dwRetLen == <span class="built_in">sizeof</span>(tokenEle) )</span><br><span class="line">        &#123;</span><br><span class="line">            bElevated = tokenEle.TokenIsElevated;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        strTip.<span class="built_in">Format</span>( _T(<span class="string">&quot;GetTokenInformation failed, GetLastError: %d&quot;</span>), <span class="built_in">GetLastError</span>() );</span><br><span class="line">        <span class="built_in">AfxMessageBox</span>( strTip );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">CloseHandle</span>( hToken );  </span><br><span class="line">    <span class="keyword">return</span> bElevated;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9、DLL延迟加载与DLL远程注入"><a href="#9、DLL延迟加载与DLL远程注入" class="headerlink" title="9、DLL延迟加载与DLL远程注入"></a>9、DLL延迟加载与DLL远程注入</h3><p><strong>在<strong><strong>第22章</strong></strong>讲到了DLL延迟加载与DLL远程注入的相关内容</strong>。下面从实际工程应用的角度去大概地讲述上述两方面的内容。</p>
<h4 id="9-1、DLL延迟加载"><a href="#9-1、DLL延迟加载" class="headerlink" title="9.1、DLL延迟加载"></a>9.1、DLL延迟加载</h4><p>当启动一个程序时，系统会给程序进程分配一个进程空间，系统会先将主程序依赖的各个dll库加载到进程空间中，当所以依赖的库加载到进程空间中后，最后才会将exe主程序加载并运行起来，然后进入exe主程序的main函数，主程序运行起来。</p>
<p>软件的某些功能是调用某个DLL库的接口实现的，但这些功能可能客户不会用或很少用，可以将相关的DLL库设置为延迟加载。设置为延迟加载后，就不会在启动主程序时就加载DLL库，而是在调用到DLL接口时再去加载，Windows系统是支持DLL延迟加载的。</p>
<p>将不怎用的功能所在的DLL库设置为延迟加载，主要有以下两大好处：</p>
<blockquote>
<p><strong>1）提高程序的启动速度</strong><br>将DLL库设置为延迟加载后，程序启动时就不会加载该DLL库，这样就能减少程序启动要加载的DLL库个数，可以提升程序的执行速度。<br><strong>2）较少程序对虚拟内存的占用</strong><br>DLL库加载到进程空间中，主要有两方面会占用程序的内存空间（虚拟内存空间）。一方面，DLL二进制文件中存放的是要CPU执行的二进制代码，加载到进程空间后会占用进程代码段的内存，这是程序虚拟内存的一部分。<br>另一方面，DLL库中有些变量，DLL加载到进程空间中后，有些变量需要分配内存，这些变量的内存则是程序数据段的内存，也是程序虚拟内存的一部分。所以减少DLL库的加载，可以降低进程对虚拟内存的占用。</p>
</blockquote>
<p>那如何将DLL设置成延迟加载呢？其实很简单，在Visual Studio中就可以设置，在exe主程序中配置即可。打开exe主程序工程的工程属性，到在<strong>链接器 -&gt; 输入 -&gt; 延迟加载的DLL</strong> 下，输入要延迟加载的DLL文件名称，如下所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/366e4598a1df876d24cb9b457e9fe832.png"></p>
<p>如果有多个DLL库需要延迟加载，用逗号隔开即可。</p>
<h4 id="9-2、DLL远程注入"><a href="#9-2、DLL远程注入" class="headerlink" title="9.2、DLL远程注入"></a>9.2、DLL远程注入</h4><p>有些软件通过DLL模块远程注入实现对目标程序的监控，其实在日常工作中一直都有DLL远程注入的身影，比如输入法之所以能在所有的软件上进行输入，是因为输入法有专门的DLL远程注入到当前系统所有的UI进程中。此外，有些第三方安全软件也是通过DLL远程注入的方式注入到目标进程中，去对目标进程的实时网络数据进行分析和监控。</p>
<h3 id="10、SEH结构化异常与C-异常"><a href="#10、SEH结构化异常与C-异常" class="headerlink" title="10、SEH结构化异常与C++异常"></a>10、SEH结构化异常与C++异常</h3><p><strong>第25章</strong><strong>（未处理异常、向量化异常处理与C++异常）中讲到了SEH结构化异常与C++异常相关的内容。</strong></p>
<h4 id="10-1、SEH结构化异常"><a href="#10-1、SEH结构化异常" class="headerlink" title="10.1、SEH结构化异常"></a>10.1、SEH结构化异常</h4><p>SEH（Structured Exception Handling），结构化异常处理，是Windows操作系统上，Microsoft对C&#x2F;C++程序语言做的语法扩展，用于处理异常事件的程序控制结构。异常事件是打断程序正常执行流程的不在期望之中的硬件、软件事件。硬件异常是CPU抛出的如“除0”、数值溢出等；软件异常是操作系统与程序通过RaiseException语句抛出的异常。</p>
<p>Microsoft扩展了C语言的语法，用 try-except与try-finally语句来处理异常。try-except结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__try </span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// guarded code</span></span><br><span class="line">&#125;</span><br><span class="line">__except ( expression )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// exception handler code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try-finally结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__try &#123;</span><br><span class="line">   <span class="comment">// guarded code</span></span><br><span class="line">&#125;</span><br><span class="line">__finally &#123;</span><br><span class="line">   <span class="comment">// termination code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常处理程序可以释放已经获取的资源、显示出错信息与程序内部状态供调试、从错误中恢复、尝试重新执行出错的代码或者关闭程序等等。一个__try语句不能既有__except，又有__finally。但try-except与try-finally语句可以嵌套使用。</p>
<p>以调用系统API函数HtmlHelp打开.chm文件为例，在项目中发现，如果目标路径中的.chm文件不存在，HtmlHelp函数内部会产生异常，导致程序崩溃，为了解决这个问题，我们添加了__try…__except进行保护，相关代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">OpenChmHelpFile</span><span class="params">( LPCTSTR lpStrPath )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HWND hHelpWnd = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        hHelpWnd = <span class="built_in">HtmlHelp</span>( <span class="literal">NULL</span>, lpStrPath, HH_DISPLAY_TOPIC, <span class="literal">NULL</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    __except( EXCEPTION_EXECUTE_HANDLER )</span><br><span class="line">    &#123;</span><br><span class="line">        hHelpWnd = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( <span class="literal">NULL</span> == hHelpWnd )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">WriteLog</span>( _T(<span class="string">&quot;[OpenChmHelpFile] HtmlHelp execute failed, path [%s]!&quot;</span>), lpStrPath );</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-2、C-异常"><a href="#10-2、C-异常" class="headerlink" title="10.2、C++异常"></a>10.2、C++异常</h4><p>C++异常处理的声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// code that could throw an exception</span></span><br><span class="line">&#125;</span><br><span class="line">[ <span class="built_in">catch</span> (exception-declaration) </span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// code that executes when exception-declaration is thrown</span></span><br><span class="line">   <span class="comment">// in the try block</span></span><br><span class="line">&#125;</span><br><span class="line">[<span class="built_in">catch</span> (exception-declaration) </span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// code that handles another exception type</span></span><br><span class="line">&#125; ] . . . ]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// The following syntax shows a throw expression:</span></span><br><span class="line"><span class="keyword">throw</span> [expression]</span><br></pre></td></tr></table></figure>

<p>C++异常处理使用try、catch和throw三个关键字实现，用throw抛出异常，然后用try…catch捕获异常。</p>
<p>比如在使用new去动态申请内存时，如果进程内存不足，申请不到指定大小的堆内存时，new内部会抛出bad_alloc异常，捕获这个异常的代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10000000000</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (bad_alloc &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-3、SEH结构化异常与C-异常的区别"><a href="#10-3、SEH结构化异常与C-异常的区别" class="headerlink" title="10.3、SEH结构化异常与C++异常的区别"></a>10.3、SEH结构化异常与C++异常的区别</h4><p>SEH 是操作系统所提供的便利，它在任何语言中都可以使用。而C++异常处理只有在编写C++代码时才可以使用。Microsof 的 Visual C++编译器使用操作系统的结构化异常机制来实现 C++异常处理机制。所以，在创建一个 C++ try 块时，编译器会为我们生成一个 SEH __try块。C++的catch 语句对应SEH 异常过滤程序，catch 块中的代码则对应SEH __except块中的代码。而编译器也会为C++ throw语句生成对WindowsRaiseException函数的调用，throw语句所使用的变量则成为RaiseException的附加参数。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/15/Obsidian%20%E5%A4%9A%E5%BA%93%E5%85%B1%E7%94%A8%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gcmz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gcmz Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Gcmz Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/15/Obsidian%20%E5%A4%9A%E5%BA%93%E5%85%B1%E7%94%A8%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-15 22:00:15" itemprop="dateCreated datePublished" datetime="2025-06-15T22:00:15+08:00">2025-06-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 00:32:29" itemprop="dateModified" datetime="2025-06-25T00:32:29+08:00">2025-06-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mklink [[/D] | [/H] | [/J]] Link Target</span><br></pre></td></tr></table></figure>

<h2 id="D-创建符号目录连接-软连接-H-文本文件链接-硬连接-J-创建目录连接-软连接-Link-要创建新链接的文件-Target-源文件"><a href="#D-创建符号目录连接-软连接-H-文本文件链接-硬连接-J-创建目录连接-软连接-Link-要创建新链接的文件-Target-源文件" class="headerlink" title="  &#x2F;D 创建符号目录连接,(软连接)  &#x2F;H 文本文件链接(硬连接)  &#x2F;J 创建目录连接(软连接)  Link 要创建新链接的文件  Target 源文件"></a>  &#x2F;D 创建符号目录连接,(软连接)<br>  &#x2F;H 文本文件链接(硬连接)<br>  &#x2F;J 创建目录连接(软连接)<br>  Link 要创建新链接的文件<br>  Target 源文件</h2><h2 id="参数-D-和-J-都是建立目录连接-H-是建立文件链接"><a href="#参数-D-和-J-都是建立目录连接-H-是建立文件链接" class="headerlink" title="  参数 &#x2F;D 和 &#x2F;J 都是建立目录连接, &#x2F;H 是建立文件链接"></a>  参数 &#x2F;D 和 &#x2F;J 都是建立目录连接, &#x2F;H 是建立文件链接</h2><p>前面是目标，后面是源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mklink /j /d   E:\Develop\Hexoblog\source\Hexo\.obsidian  D:\AllSoftware\Obsidian\Ev\.obsidian</span><br><span class="line"></span><br><span class="line">mklink /j /d   E:\Develop\Project\WinKernelProgram\WinKernelProgram\.obsidian  D:\AllSoftware\Obsidian\Ev\.obsidian</span><br><span class="line"></span><br><span class="line">mklink /j /d   E:\Develop\Note\.obsidian  D:\AllSoftware\Obsidian\Ev\.obsidian</span><br></pre></td></tr></table></figure>


<p>mlink 命令使用也可以看这里</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4268d00450c2">https://www.jianshu.com/p/4268d00450c2</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/02/debug/%E4%BE%8B%E5%AD%90/%E3%80%8AWindows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B%E8%8B%A5%E5%B9%B2%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8%E5%88%86%E4%BA%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gcmz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gcmz Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Gcmz Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/02/debug/%E4%BE%8B%E5%AD%90/%E3%80%8AWindows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B%E8%8B%A5%E5%B9%B2%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8%E5%88%86%E4%BA%AB/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-06-02 22:22:57 / 修改时间：22:42:54" itemprop="dateCreated datePublished" datetime="2025-06-02T22:22:57+08:00">2025-06-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1、进程的虚拟内存分区"><a href="#1、进程的虚拟内存分区" class="headerlink" title="1、进程的虚拟内存分区"></a>1、进程的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">虚拟内存</a>分区</h3><p><strong>在**<strong>13.2节</strong></strong>（虚拟地址空间的分区）中讲到了进程的虚拟内存分区**，如下所示：</p>
<p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202506022223711.png" alt="image.png"></p>
<h4 id="1-1、用户态虚拟内存与内核态虚拟内存"><a href="#1-1、用户态虚拟内存与内核态虚拟内存" class="headerlink" title="1.1、用户态虚拟内存与内核态虚拟内存"></a>1.1、用户态虚拟内存与内核态虚拟内存</h4><p>程序的虚拟内存主要分为用户态虚拟内存区和内核态虚拟内存区，比如对于一个32位程序，系统会给进程分配4GB的虚拟内存，默认情况下用户态虚拟内存占2GB，内核态虚拟内存占2GB。</p>
<p>一般程序的业务模块主要运行在用户态虚拟内存中，驱动相关的模块则可能运行在内核态虚拟内存中。运行在用户态的模块禁止访问内核态内存地址，运行在内核态的模块禁止访问用户态虚拟内存。</p>
<blockquote>
<p>**在程序发生内存异常时，可能会出现用户态模块访问内核态内存地址的情况，会产生内存访问违例，程序发生崩溃。具体的表现为，发生崩溃的那条汇编指令中访问了一个很大的内核态内存地址，比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov     edx,dword ptr [eax]  ds:002b:fc8b7653=????????</span><br></pre></td></tr></table></figure>

<p>上述汇编指令中访问了一个很大的内存地址0xfc8b7653，对于32位程序来说，该地址属于内核态的内存地址。</p>
</blockquote>
<blockquote>
<p>**有人可能会说直接看C++代码就好了，为什么还要查看汇编呢？**因为程序发生崩溃时，最终是崩溃在某条汇编指令上，查看汇编代码能看出发生崩溃的最直接原因，比如指令中访问了不该访问的内存，例如访问了很小的内存（小地址内存区的内存）或者访问了很大的内存地址（内核态虚拟内存区的内存）。此外，一行代码可能由几个子句构成，通过查看汇编代码上下文，就能确定到底是哪个子句出的问题。 </p>
</blockquote>
<p>   对于32位程序，默认用户态虚拟内存占用2GB，如果程序中的业务模块庞大（需要占用大量的内存），而业务模块基本都运行在用户态虚拟内存中，默认的2GB的虚拟内存可能不够用，可以通过设置将用户态虚拟内存从2GB扩展到3GB。具体的做法是，<strong>在Visual Studio的工程属性中可以开启</strong><strong>&#x2F;LARGEADDRESSAWARE****启用大地址选项</strong>：（链接器 -&gt; 系统 -&gt; 启动大地址）<br>   <br><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202506022224519.png" alt="image.png"></p>
<p>这样用户态的虚拟内存就会从默认的2GB扩充到3GB，内核态内存也就变到了1GB。</p>
<p>   用户态虚拟内存达到上限，可能有两个原因：</p>
<blockquote>
<p><strong>1）程序中有内存泄漏，多次泄漏将内存耗尽了</strong><br>有内存泄漏的代码频繁地被执行，内存持续地被占用不释放，导致程序占用的虚拟内存接近或达到用户态虚拟内存的上限。对于这种情况，则要排查内存泄漏的点，彻底消除内存泄漏。<br><strong>2）程序中包含了多个业务模块，确实要占用大量的用户态内存</strong><br>程序中包含了多个业务模块，确实要占用大量的用户态虚拟内存。比如我们软件中使用WebRTC开源库，很庞大，初始化时会申请大量的内存（一上来很多业务就会将内存分配好），即启动时就会占用大量的内存。软件除了WebRTC库，还包含了多个业务模块，这样加起来占用的虚拟内存就更大了。</p>
</blockquote>
<p>对于这种情况，我们需要优化代码，减少程序对内存的占用。有一个重要的原则，需要使用时再去申请，不再使用时立即将内存释放掉。</p>
<p>   后来<strong>我们用Process Explorer工具观察软件在运行过程中占用的总虚拟内存大小（用户态的虚拟内存）：</strong></p>
<p><img src="https://i-blog.csdnimg.cn/direct/bada6ebe895240bf8f65e7c32e158ea4.png"></p>
<p>在崩溃时间点左右，程序的用户态内存已经接近32位程序默认的2GB的用户态虚拟内存的上限了（注意上图中不是当时的问题截图，只是一个查看程序虚拟内存占用的实例）。进一步排查，排除了内存泄漏的存在，是因为软件中的多个业务模块确实需要占用大量的内存空间。于是从上层到底层对内存占用进行了一些优化，虽然减少出问题的概率，但还是会出现闪退的问题。</p>
<p>   因为时间仓促，涉及到底层的多个模块，一时半会很难进行较大的优化。后来就开启了大地址选项，即将32位程序的2GB的用户态虚拟内存扩充了3GB，暂时将这个问题规避掉。经后续测试验证，确实有效地解决了问题。至于如何开启32位程序的大地址模式，<strong>只要在exe主程序的工程属性</strong>中开启&#x2F;LARGEADDRESSAWARE大地址选项即可：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/60136e98c9e7aa36e668ef37b8a742a3.png"></p>
<h4 id="1-2、小于0x10000的小地址内存区"><a href="#1-2、小于0x10000的小地址内存区" class="headerlink" title="1.2、小于0x10000的小地址内存区"></a>1.2、小于0x10000的小地址内存区</h4><p>       Windows系统专门预留了一块从0到0x10000的小地址内存区，又称空指针内存区或空指针赋值内存分区：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/571ade4ce4337f789873a924df944136.png"></p>
<p>专门为了帮程序员定位访问空指针的问题。</p>
<p>   当访问到这个内存区域时，就会触发内存访问违例，系统会强制将进程终止掉。为什么使用空指针就会访问到这个小地址内存区呢？比如类对象指针值为NULL，代码中没有判断指针是否为空，直接使用该指针去访问指向的类的成员变量，即将NULL值作为C++类对象的首地址，那么类对象的数据成员的内存地址就是相对于所在对象地址NULL的偏移，即成员变量的地址是个很小的内存地址，而访问变量的值就是去读或写该变量的内存地址中的内容，就是去访问变量的内存，这样就会去访问一个很小的内存地址，即访问空指针赋值区，就会触发内存访问违例，引发崩溃。</p>
<blockquote>
<p><strong>这里涉及了类对象中的成员变量内存在类对象中排布问题</strong>，成员变量的内存地址都是相对于所在类对象的内存地址的偏移！比如某案例中因为空指针访问了一个很小的内存地址（小地址内存区），产生内存访问违例发生崩溃，发生崩溃的那条汇编指令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov     edx,dword ptr [eax]  ds:002b:00000124=????????</span><br></pre></td></tr></table></figure>

<p>该汇编指令中访问的0x00000124，是个很小的内存地址，属于空指针内存区，是禁止访问的，所以产生了内存访问违例。</p>
</blockquote>
<blockquote>
<p>空指针是引发程序异常的常见原因之一。另外，访问已经释放内存的野指针，分析思路也是类似的，即类的成员变量的地址是相对所在类对象地址的偏移。</p>
</blockquote>
<p>   **这个地方有一点需要提一下，使用空指针去调用类的成员函数是否一定会导致崩溃呢？答案是不一定，不一定会导致崩溃，这主要看有没有访问不应该访问的内存。比如被调用函数中没有访问类的数据成员（成员变量，占用的是数据段内存），即不会访问类对象的内存，就不会崩溃。</p>
<blockquote>
<p>调用的函数执行的是代码段上的指令，调用函数本身并不会有异常。这里要区分数据段内存与代码段内存。</p>
</blockquote>
<p>但如果使用空指针去调用虚函数，会涉及到虚函数的二次寻址，即先去访问类对象中隐含的虚函数表指针中的内容（存放的虚函数表的首地址），虚函数表指针变量的地址就是其所属的C++类对象的首地址，就会因为空指针访问很小的内存地址，引发内存访问违例。</p>
<h3 id="2、保存线程上下文的CONTEXT结构体"><a href="#2、保存线程上下文的CONTEXT结构体" class="headerlink" title="2、保存线程上下文的CONTEXT结构体"></a>2、保存线程上下文的CONTEXT<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BB%93%E6%9E%84%E4%BD%93&spm=1001.2101.3001.7020">结构体</a></h3><p><strong>在**<strong>7.7节</strong></strong>（在实际上下文中谈CONTEXT结构体）中讲到了保存线程上下文信息的CONTEXT结构体。在多个线程之间切换时会使用到系统定义的CONTEXT结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Context Frame</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  This frame has a several purposes: 1) it is used as an argument to</span></span><br><span class="line"><span class="comment">//  NtContinue, 2) is is used to constuct a call frame for APC delivery,</span></span><br><span class="line"><span class="comment">//  and 3) it is used in the user level thread creation routines.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  The layout of the record conforms to a standard call frame.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CONTEXT</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The flags values within this flag control the contents of</span></span><br><span class="line">    <span class="comment">// a CONTEXT record.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If the context record is used as an input parameter, then</span></span><br><span class="line">    <span class="comment">// for each portion of the context record controlled by a flag</span></span><br><span class="line">    <span class="comment">// whose value is set, it is assumed that that portion of the</span></span><br><span class="line">    <span class="comment">// context record contains valid context. If the context record</span></span><br><span class="line">    <span class="comment">// is being used to modify a threads context, then only that</span></span><br><span class="line">    <span class="comment">// portion of the threads context will be modified.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If the context record is used as an IN OUT parameter to capture</span></span><br><span class="line">    <span class="comment">// the context of a thread, then only those portions of the thread&#x27;s</span></span><br><span class="line">    <span class="comment">// context corresponding to set flags will be returned.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The context record is never used as an OUT only parameter.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"> </span><br><span class="line">    DWORD ContextFlags;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This section is specified/returned if CONTEXT_DEBUG_REGISTERS is</span></span><br><span class="line">    <span class="comment">// set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT</span></span><br><span class="line">    <span class="comment">// included in CONTEXT_FULL.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"> </span><br><span class="line">    DWORD   Dr0;</span><br><span class="line">    DWORD   Dr1;</span><br><span class="line">    DWORD   Dr2;</span><br><span class="line">    DWORD   Dr3;</span><br><span class="line">    DWORD   Dr6;</span><br><span class="line">    DWORD   Dr7;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This section is specified/returned if the</span></span><br><span class="line">    <span class="comment">// ContextFlags word contians the flag CONTEXT_FLOATING_POINT.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"> </span><br><span class="line">    FLOATING_SAVE_AREA FloatSave;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This section is specified/returned if the</span></span><br><span class="line">    <span class="comment">// ContextFlags word contians the flag CONTEXT_SEGMENTS.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"> </span><br><span class="line">    DWORD   SegGs;</span><br><span class="line">    DWORD   SegFs;</span><br><span class="line">    DWORD   SegEs;</span><br><span class="line">    DWORD   SegDs;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This section is specified/returned if the</span></span><br><span class="line">    <span class="comment">// ContextFlags word contians the flag CONTEXT_INTEGER.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"> </span><br><span class="line">    DWORD   Edi;</span><br><span class="line">    DWORD   Esi;</span><br><span class="line">    DWORD   Ebx;</span><br><span class="line">    DWORD   Edx;</span><br><span class="line">    DWORD   Ecx;</span><br><span class="line">    DWORD   Eax;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This section is specified/returned if the</span></span><br><span class="line">    <span class="comment">// ContextFlags word contians the flag CONTEXT_CONTROL.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"> </span><br><span class="line">    DWORD   Ebp;</span><br><span class="line">    DWORD   Eip;</span><br><span class="line">    DWORD   SegCs;              <span class="comment">// MUST BE SANITIZED</span></span><br><span class="line">    DWORD   EFlags;             <span class="comment">// MUST BE SANITIZED</span></span><br><span class="line">    DWORD   Esp;</span><br><span class="line">    DWORD   SegSs;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This section is specified/returned if the ContextFlags word</span></span><br><span class="line">    <span class="comment">// contains the flag CONTEXT_EXTENDED_REGISTERS.</span></span><br><span class="line">    <span class="comment">// The format and contexts are processor specific</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"> </span><br><span class="line">    BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];</span><br><span class="line"> </span><br><span class="line">&#125; CONTEXT;</span><br></pre></td></tr></table></figure>


<p>线程是分配CPU时间片的基本单元，线程失去CPU时间片后，线程就会被挂起，进入了睡眠状态；线程获取到了CPU时间片，则会从睡眠中唤醒，继续执行。</p>
<p><strong>线程失去时间片时</strong>，会将线程上下文中的寄存器等信息保存到CONTEXT结构体中，然后进入挂起（睡眠）状态；<strong>当线程获取CPU时间片后</strong>，则会从之前保存的CONTEXT结构体中把之前保存的寄存器信息给读出来，放到当前的寄存器中，然后线程继续接着挂起前的状态继续运行。这点对于从汇编角度去理解多线程代码的执行细节很重要。</p>
<h3 id="3、从汇编代码角度去理解多线程运行过程的典型实例"><a href="#3、从汇编代码角度去理解多线程运行过程的典型实例" class="headerlink" title="3、从汇编代码角度去理解多线程运行过程的典型实例"></a>3、从汇编代码角度去理解多线程运行过程的典型实例</h3><p>在8.1节（原子访问:Interlocked 系列函数）中讲到的那个多线程实例，虽然很简单，但它是从汇编角度去理解多线程代码执行细节的典型实例。从汇编代码的角度才能将这个实例理解透彻的！</p>
<p>该例子中定义了一个long型的全局变量，然后创建了两个线程，线程函数分别是ThreadFunc1和ThreadFunc2，这两个线程函数中均对g_x变量进行自加操作（在访问共享变量g_x时未加锁同步），相关代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define a global variable</span></span><br><span class="line"><span class="type">long</span> g_x = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadFunc1</span><span class="params">(PVOID pvParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_x++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadFunc2</span><span class="params">(PVOID pvParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_x++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个问题，<strong>当这两个线程函数执行完后，全局变量g_x的值会是多少呢？一定会是2吗？</strong></p>
<p>   实际上，<strong>在两个线程函数执行完后，g_x的值不一定为2</strong>。这个实例需要从汇编代码的角度去理解，从C++源码看则很难搞懂，这是一个从汇编代码角度去理解代码执行细节的典型实例。</p>
<blockquote>
<p>熟悉汇编代码，不仅可以辅助排查C++软件异常，还可以理解很多高级语言无法理解的代码执行细节。</p>
</blockquote>
<p>   <em>有些人可能觉得，代码中就是一个自加的操作，一下子就执行完了，中间应该不会被打断。<strong>会不会被打断，其实要看汇编代码的</strong></em>，这行C++源码对应三行汇编代码，对g_x变量的自加这句C++代码，对应的汇编代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX, [g_x]  // 将g_x变量的值读到EAX寄存器中</span><br><span class="line">INC EAX         // 将EAX中的值执行自加操作</span><br><span class="line">MOV [g_x], EAX  // 然后将EAX中的值设置到g_x变量内存中</span><br></pre></td></tr></table></figure>

<p>看C++代码：g_x++，只能保证CPU执行某条<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4&spm=1001.2101.3001.7020">汇编指令</a>时不会被打断（汇编指令是CPU执行的最小粒度），但3条汇编指令，指令与指令之间是可能被打断的。</p>
<p>  为什么说两个线程执行完成后g_x变量的值是不确定的呢？比如可能存在两种场景：</p>
<p><strong>1）场景1（最终结果g_x&#x3D;2）</strong> </p>
<p>  假设线程1先快速执行了三行汇编指令，未被打断，g_x的值变成1。然后紧接着线程2执行，在g_x&#x3D;1的基础上累加，最终两个线程执行完后，g_x等于2。</p>
<p><strong>2）场景2（最终结果g_x&#x3D;1）</strong></p>
<p>  假设线程1先执行，当执行完前两条汇编指令后，线程1失去时间片（线程上下文信息保存到CONTEXT结构体中）：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/79ead2f1e701b449f1309ff38eefa9e4.png"></p>
<p>即线程1前两条汇编指令执行完，第3条汇编指令还没来得及执行，就失去CPU时间片了！</p>
<p>线程2执行，一次执行完三条指令，当前g_x&#x3D;1。然后线程1获得CPU时间片，因为上次执行两条汇编指令后EAX寄存器中的值为1，因为线程1获取了时间片，保存线程上下文信息的CONTEXT恢复到线程1中，EAX&#x3D;1，继续执行第3条指令，执行完后g_x还是1。</p>
<p><strong>所以，这个多线程问题，需要从汇编代码的角度去理解，从C++源码的角度很难想明白。</strong></p>
<p>从本例可以看出，即使是简单的变量自加操作，多线程操作时也要做同步，可以加锁，可以使用**<em>系统的原子锁Interlocked系列函数</em>**，比如原子自加函数InterlockedIncrement和原子自减函数InterlockedDecrement：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">InterlockedIncrement</span><span class="params">(  </span></span></span><br><span class="line"><span class="params"><span class="function">    LPLONG <span class="keyword">volatile</span> lpAddend   <span class="comment">// variable to increment</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">LONG <span class="title">InterlockedDecrement</span><span class="params">(  </span></span></span><br><span class="line"><span class="params"><span class="function">    LPLONG <span class="keyword">volatile</span> lpAddend   <span class="comment">// variable address</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这些原子函数能保证会被原子地被执行，中间不会被打断。 修改后的代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define a global variable</span></span><br><span class="line"><span class="type">long</span> g_x = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadFunc1</span><span class="params">(PVOID pvParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InterlockedIncrement（&amp;g_x）;  <span class="comment">// 调用原子锁函数InterlockedIncrement实现自加</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadFunc2</span><span class="params">(PVOID pvParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InterlockedIncrement（&amp;g_x）;  <span class="comment">// 调用原子锁函数InterlockedIncrement实现自加</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="4、调用TerminateThread强制结束线程会导致线程中的资源没有释放的问题"><a href="#4、调用TerminateThread强制结束线程会导致线程中的资源没有释放的问题" class="headerlink" title="4、调用TerminateThread强制结束线程会导致线程中的资源没有释放的问题"></a>4、调用TerminateThread强制结束线程会导致线程中的资源没有释放的问题</h3><p><strong>在**<strong>6.5节</strong></strong>（终止运行线程）中讲到了调用TerminateThread结束线程的相关问题。</p>
<p>创建线程时需要指定线程函数，当代码执行到线程函数中，线程才真正运行起来。线程函数执行完了，线程函数退出了，线程也就退出了。线程结束了，可能是线程函数自然执行完成了，也可能是人为地调用TerminateThread接口强制将进程退出了。</p>
<p>当线程函数自然地执行完退出时，函数中局部变量的栈内存会自动被释放，函数中的资源才会自动地被释放。如果线程函数执行的过程中被TerminateThread函数强行终止了，则会导致函数中的资源不会被释放，比如：</p>
<blockquote>
<p><strong>1）线程函数中局部变量的栈内存没有释放</strong><br>函数没有正常地执行完成，函数中局部变量占用的栈内存没有释放。<br><strong>2）线程函数中申请的资源没有释放</strong></p>
<p>比如线程函数中刚拿到一个锁，就被强行终止了，释放锁的代码没有执行到，导致线程结束了锁也没被释放掉。有次我们在用Windbg排查多线程死锁问题时，一个线程在申请锁，但通过查看锁信息得知该锁被另一个线程占用着，但我们查看进程的线程列表时并没有找到占用锁的那个线程id，估计线程已经结束了，可能就是因为该线程中途被Terminate掉了，还没将锁释放掉，线程就被终止了，所以出现了这个问题。</p>
</blockquote>
<p>此外，线程终止与进程终止是有区别的，线程被强行终止时系统不会去释放线程中的资源，但进程终止时系统会释放进程所有的资源。</p>
<h3 id="5、调用WaitForSingleObject监测目标程序有没有退出"><a href="#5、调用WaitForSingleObject监测目标程序有没有退出" class="headerlink" title="5、调用WaitForSingleObject监测目标程序有没有退出"></a>5、调用WaitForSingleObject监测目标程序有没有退出</h3><p><strong>在**<strong>4.4节</strong></strong>（子进程）中讲到了可以通过WaitForSingleObject监测目标程序有没有退出**。</p>
<h4 id="5-1、WaitForSingleObject函数说明"><a href="#5-1、WaitForSingleObject函数说明" class="headerlink" title="5.1、WaitForSingleObject函数说明"></a>5.1、WaitForSingleObject函数说明</h4><p>WaitForSingleObject 函数可以等待以下对象：</p>
<blockquote>
<ul>
<li>更改通知</li>
<li>控制台输入</li>
<li>可等待计时器</li>
<li>内存资源通知</li>
<li>事件（Event）</li>
<li>互斥量（Mutex）</li>
<li>信号量（Semaphore）</li>
<li>线程</li>
<li>进程</li>
</ul>
</blockquote>
<p>当等待对象从非触发状态变成触发状态（发出信号）， WaitForSingleObject就会返回；或者是等待时间超时，WaitForSingleObject也会返回。关于WaitForSingleObject的返回值如下所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4ca27a6a6386f0ab56a89ae71dc7af08.png"></p>
<p><strong>对于事件</strong>，分有信号和无信号两个状态，当事件对象编程有信号时，WaitForSingleObject立即返回。</p>
<p><strong>对于互斥量和信号量</strong>，调用WaitForSingleObject获取所有权，即WaitForSingleObject返回WAIT_OBJECT_0时获取他们的所有权，然后调用ReleaseMutex和ReleaseSemaphore释放对象的所有权。</p>
<p><strong>对于线程和进程</strong>，线程和进程创建时无信号，当线程和进程退出时对应的句柄就变成了有信号，这样WaitForSingleObject就返回了。可以通过WaitForSingleObject返回，判断线程或进程是否已经退出了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread, INFINITE); <span class="comment">// 参数INFINITE表示无限等待</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2、调用WaitForSingleObject函数监测线程或进程是否已经退出"><a href="#5-2、调用WaitForSingleObject函数监测线程或进程是否已经退出" class="headerlink" title="5.2、调用WaitForSingleObject函数监测线程或进程是否已经退出"></a>5.2、调用WaitForSingleObject函数监测线程或进程是否已经退出</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b392410ee9bc28d119582005ec4fcf44.png"></p>
<p>在主程序运行的过程中启动了一个子进程，有时主进程要等待子进程处理结果后根据返回的信息再控制后续代码的执行，有时子进程需要感知主进程是否已经退出，这两种情况都需要感知另一个进程是否已经退出。对于线程在某些场合下页存在类似的需求。</p>
<h5 id="5-2-1、子进程实时监测主进程是否已经退出，主进程退出了，则子进程要自动退出"><a href="#5-2-1、子进程实时监测主进程是否已经退出，主进程退出了，则子进程要自动退出" class="headerlink" title="5.2.1、子进程实时监测主进程是否已经退出，主进程退出了，则子进程要自动退出"></a>5.2.1、子进程实时监测主进程是否已经退出，主进程退出了，则子进程要自动退出</h5><p>主进程在运行过程中启动了一个子进程，启动子进程时将主进程的进程id传给子进程。子进程是依赖于主进程存活的，如果主进程退出或者崩溃了，则子进程就没有存在的意义了，要自动退出！所以子进程要实时监测主进程的状态，监测主进程有没有退出（包括崩溃闪退）。</p>
<p>可能有人会说，主进程可以在退出时通知子进程，子进程收到通知后再自行退出。<strong>但主进程可能会发生崩溃或闪退，这种情况下一般时没法通知子进程的。</strong></p>
<p>那子进程如何才能实时监测主进程是否退出了呢？不管是主进程正常退出，还是异常崩溃闪退，都要感知到。子进程可以启动一个子线程，在子线程中通过主进程传过来的主进程id，获取主进程句柄，然后调用WaitForSingleObject等待主进程退出，可以在子线程中无限等待。如果主进程一旦退出，WaitForSingleObject函数就会立即返回，这时子进程就可以调用ExitProcess等接口自行退出当前子进程了。</p>
<p>具体的代码实现是，子进程中启动一个子线程，将主进程传过来的主进程id传给该子线程，如下：（其中MonitorMainProcess是线程函数）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hThread = (HANDLE)_beginthreadex( <span class="literal">NULL</span>, <span class="number">0</span>, MonitorMainProcess, (<span class="type">void</span>*)dwMainProcessId, <span class="number">0</span>, <span class="literal">NULL</span> );</span><br><span class="line"><span class="keyword">if</span> ( hThread != <span class="literal">NULL</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CloseHandle</span>( hThread );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程函数MonitorMainProcess实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监控主工程</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> __stdcall <span class="title">MonitorMainProcess</span><span class="params">(<span class="type">void</span> * pParam )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD dwProcessId = (DWORD)pParam;</span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>( SYNCHRONIZE, FALSE, dwProcessId );</span><br><span class="line">    <span class="keyword">if</span>(hProcess == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ExitProcess</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 设置INFINITE无限等待</span></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>( hProcess, INFINITE );</span><br><span class="line">    <span class="built_in">CloseHandle</span>( hProcess );</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// WaitForSingleObject返回了，就表示主进程已经退出，直接退出本进程</span></span><br><span class="line">    <span class="built_in">ExitProcess</span>( <span class="number">-1</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>进程初始是无信号的，进程退出时就变成了有信号，这样WaitForSingleObject等待到信号后，就返回了，这样子进程就直到主进程退出了。</p>
<p>此处需要注意一下，调用OpenProcess时必须要设置SYNCHRONIZE参数，因为设置该标记参数后才能调用WaitForSingleObject去等待进程。微软MSDN上对SYNCHRONIZE如下：</p>
<blockquote>
<p><strong>SYNCHRONIZE</strong>：The right to use the object for synchronization. This enables a thread to wait until the object is in the signaled state.</p>
</blockquote>
<p>此外，监测主进程是否退出的代码是阻塞式的，不能放在主线程中的，这就是为什么要启动一个子线程去专门做这个监测任务的原因。</p>
<h5 id="5-2-2、启动子进程后等待子进程执行完退出后，再执行后续操作"><a href="#5-2-2、启动子进程后等待子进程执行完退出后，再执行后续操作" class="headerlink" title="5.2.2、启动子进程后等待子进程执行完退出后，再执行后续操作"></a>5.2.2、启动子进程后等待子进程执行完退出后，再执行后续操作</h5><p>有时我们需要启动一个子进程去完成某项操作，主进程在等待子进程的执行结果（需要获取子进程的执行数据）， 然后主进程再去执行后续操作。主进程在启动子进程后，就可以调用WaitForSingleObject等待子进程退出，比如如下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动一个子进程去执行一个操作任务</span></span><br><span class="line">STARTUPINFO s  = &#123;<span class="built_in">sizeof</span>(s)&#125;; </span><br><span class="line">PROCESS_INFORMATION   pi = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">CreateProcess</span>( <span class="literal">NULL</span>, cmdLine, <span class="literal">NULL</span>, <span class="literal">NULL</span>, TRUE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;s, &amp;pi ) )</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 等待进程执行完毕   </span></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>( pi.hProcess, INFINITE );   </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 关闭进程和主线程句柄</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>( pi.hProcess );   </span><br><span class="line">    <span class="built_in">CloseHandle</span>( pi.hThread );   </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">// ...  // 去拿子进程的执行结果，去执行后续操作</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有时启动一个子线程，要等子线程执行完退出后，根据处理结果信息去继续执行，和上面等待进程退出是类似的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/26/debug/%E4%BE%8B%E5%AD%90/Windows%20UAC%E6%9D%83%E9%99%90%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8Awindbg%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gcmz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gcmz Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Gcmz Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/26/debug/%E4%BE%8B%E5%AD%90/Windows%20UAC%E6%9D%83%E9%99%90%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8Awindbg%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-05-26 22:32:50 / 修改时间：23:05:07" itemprop="dateCreated datePublished" datetime="2025-05-26T22:32:50+08:00">2025-05-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1、什么是UAC？"><a href="#1、什么是UAC？" class="headerlink" title="1、什么是UAC？"></a>1、什么是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=UAC&spm=1001.2101.3001.7020">UAC</a>？</h3><p><strong>UAC（User Account Control），用户帐户控制，是微软从Windows Vista开始引入的一种新的控制机制</strong>，其原理是通知用户是否对应用程序使用硬盘驱动器和系统文件授权，以达到阻止恶意程序（有时也称为“恶意软件”）损坏系统的目的。</p>
<blockquote>
<p>UAC用户账户控制机制主要是权限隔离，防止低权限、低安全的应用获取系统高等级权限。系统弹出UAC提示框，让用户确认是否信任、是否以管理员权限运行未知、未签名应用。</p>
</blockquote>
<p>当运行一些会影响系统安全的程序时，会自动触发UAC，用户确认后程序才能运行。比如当你运行一个安装程序（一般以管理员权限运行）或者打开一个未经验证的程序时，就会弹出类似如下的UAC提示框：（以在Win10系统中双击需要以管理员权限运行的QQ安装包程序为例）</p>
<p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505262255020.png" alt="image.png"></p>
<p>用户确认后程序才能继续运行。</p>
<p>这个弹框是提示用户程序可能会对当前计算机进行修改，但这个提示对对绝大部分用户来说，好像并没有什么用。对普通用户而言，不但没什么用，反而会带来困扰（到底是该允许呢？还是不允许呢？）。并且老是时不时地弹框，用户也很厌烦！</p>
<p>稍微专业的用户，可能会将UAC通知关闭掉。具体方法是，打开控制面板，然后点击“用户账户”，进入用户账户设置页面：<br>       <br><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505262255546.png" alt="image.png"></p>
<p>然后点击“更改用户账户控制设置”，到如下的页面中：</p>
<p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505262255909.png" alt="image.png"></p>
<p>将滚动条拉到底，就可以将UAC通知关闭掉。关闭后，就不会再弹UAC提示框了。</p>
<p>既然大家都不喜欢UAC提示框，微软为什么还要设计出这样一个别脚的东西来呢？</p>
<h3 id="2、微软为什么要设计UAC？"><a href="#2、微软为什么要设计UAC？" class="headerlink" title="2、微软为什么要设计UAC？"></a>2、微软为什么要设计UAC？</h3><p>很多人都用过Windows XP，大多数人在用Windows XP时，使用的应该是管理员权限的账户。而在微软的设想中，普通用户都应该都使用标准账户。为什么大家不用标准账户？Windows XP里的标准账户，可能连程序都没法正常安装！没有人愿意为了装个程序，切换到管理员账户，装完了再切换回标准用户。</p>
<p>  当然，微软也注意到了这一点，于是就设计了UAC系统。UAC与Windows XP的用户账户权限管理，最大的不同在于，UAC对权限的控制很有弹性。它默认所有程序都是以标准权限运行的（无论你使用的是管理员账户还是标准账户），而当你运行一个需要管理员权限运行的程序时，UAC就会跑出来问你，这个程序需要管理员权限，要不要继续，如下：<br>  <img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505262256885.png" alt="image.png"></p>
<p>如果你允许，UAC就会提升权限，用管理员权限运行这个程序。</p>
<p>其实从UAC的设计的本意上来看，它即避免了直接使用管理员账户导致权限控制形同虚设，又解决了标准用户需要频繁切换到管理员账户的问题（可能是模仿Linux系统中的su权限提升）。</p>
<p>但Windows下的UAC一点也不智能，连复制文件之类的操作，甚至都会跑过来问你一下，很多用户不厌其烦，直接把UAC一关了事。尽管Windows对UAC做了一些改变和优化，但UAC还是很烦。比如，你第一次打开一个需要管理员权限的程序，UAC会尽忠职守地问你是否要提升权限；你第二次打开，UAC还会尽忠职守地问你是否要提升权限；你第三次打开，UAC还会尽忠职守地问你是否要提升权限……于是大家不愿意了，把UAC一关了之。</p>
<h3 id="3、标准用户权限与管理员权限"><a href="#3、标准用户权限与管理员权限" class="headerlink" title="3、标准用户权限与管理员权限"></a>3、标准<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90&spm=1001.2101.3001.7020">用户权限</a>与管理员权限</h3><p>Windows从Vista系统开始就引入了UAC权限控制机制，强化了管理员权限的概念，做了更严格的权限限制与安全控制。比如对一些权限敏感的路径，比如C:\Program Files、C:\Windows\system32，如果要在这些路径下创建文件、向文件中写数据，都是需要管理员权限的。再比如，在Windows系统的注册表中，如果要向HKEY_LOCAL_MACHINE路劲下写入或修改内容时，也需要管理员权限的。</p>
<p>程序运行权限主要有标准用户权限和管理员权限两种。有很多操作，都需要管理员权限，比如：</p>
<blockquote>
<p>1）管理员权限的程序才能向系统安全敏感路径执行写操作，比如在C:\Program Files、C:\Windows\system32等系统路径中创建文件、拷贝文件，向这些路径下的文件执行写操作。<br>2）只有管理员权限的程序，才能向系统注册表路径HKEY_LOCAL_MACHINE下执行创建或写操作。没有管理员权限的程序，只能对HKEY_CURRENT_USER路径下执行写操作。<br>3）只有管理员权限的程序，才能向系统注册控件（要向HKEY_LOCAL_MACHINE路径下的注册表写入信息）。</p>
</blockquote>
<p>安装包程序一般默认是将程序默认安装到C:\Program Files路径中，需要向系统注册控件，这些操作都需要管理员权限才能执行，所以安装包程序一般都要设置以管理员权限运行。如果程序设置了以管理员权限运行的属性，则程序图标的右下角会显示小盾牌的图标，如下所示：<br><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505262256867.png" alt="image.png"></p>
<blockquote>
<p>注意，如果在超级管理员Administrator登录的场景下，是看不到小盾牌的，因为在超级管理员登录的情况下，所有程序默认以管理员权限运行，不管程序有没有设置以管理员权限运行。</p>
</blockquote>
<p>此外，<strong>对于以标准用户权限运行的程序，如果要执行需要管理员权限才能正常执行的操作</strong>，会涉及到一个<strong>系统重定向</strong>的问题</p>
<h3 id="4、程序到底以哪种权限运行？与哪些因素有关？"><a href="#4、程序到底以哪种权限运行？与哪些因素有关？" class="headerlink" title="4、程序到底以哪种权限运行？与哪些因素有关？"></a>4、程序到底以哪种权限运行？与哪些因素有关？</h3><p>程序有没有以管理员权限运行，主要和两个因素有关，一个是当前系统登录的用户类型（标准用户、管理员用户以及超级管理员用户），一个是程序有没有设置以管理员权限运行的属性。下面以win10系统来说明，win10系统和win7系统有一些不同的，不过大体上是一样的。</p>
<h4 id="4-1、给程序设置以管理员权限运行的属性"><a href="#4-1、给程序设置以管理员权限运行的属性" class="headerlink" title="4.1、给程序设置以管理员权限运行的属性"></a>4.1、给程序设置以管理员权限运行的属性</h4><p>如何给程序设置以管理员权限运行的属性呢？对于Visual Studio编译的程序，设置以管理员权限运行比较简单。只要在exe主程序的<strong>工程属性中，链接器 -&gt; 清单文件 -&gt; UAC执行级别</strong>，如下所示：</p>
<p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505262257058.png" alt="image.png"></p>
<p>我们选择reguireAdministrator选项就可以了。<strong>设置这个属性后，程序在启动时会自动向系统申请以管理员权限运行。</strong></p>
<blockquote>
<p>如果当前登录的管理员用户，则程序启动时直接以管理员权限运行。如果当前登录的是标准用户，则启动时会弹出提权的提示框，需要输入一个管理员账户和密码才能将程序启动起来。</p>
</blockquote>
<h4 id="4-2、当前登录用户的类型"><a href="#4-2、当前登录用户的类型" class="headerlink" title="4.2、当前登录用户的类型"></a>4.2、当前登录用户的类型</h4><p>程序到底以哪种权限运行，除了设置以管理员权限运行的属性外，还和当前登录的用户有关。</p>
<p><strong>4.2.1、超级管理员Administrator登录</strong></p>
<p>如果使用Administrator超级管理员登录，不管程序有没有设置以管理员权限运行，都会以管理员权限运行。超级管理员Administrator的权限是最高的。</p>
<p>在Windows系统中，默认情况下，超级管理员Administrator是禁用的，可以通过这样的途径来开启：右键计算机 -&gt;管理 -&gt;系统工具 -&gt;本地用户和组 -&gt;用户 -&gt;右键Administrator -&gt;属性 -&gt;取消账户禁用：</p>
<p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505262258831.png" alt="image.png"></p>
<p>超级管理员在用户管理中是可以重命名的。</p>
<p><strong>4.2.2、管理员用户登录</strong></p>
<p>这里讲的管理员是普通管理员，不是超级管理员。可以右键点击程序，在弹出的右键菜单中点击“以管理员身份运行”：</p>
<p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505262258917.png" alt="image.png"></p>
<p>需要输入管理员账户和密码，要提权到管理员账户，然后才能以管理员权限运行。如果取消管理员账户的登录，则程序启动失败。</p>
<h3 id="5、案例1-无法在企业微信聊天框中启动安装包程序"><a href="#5、案例1-无法在企业微信聊天框中启动安装包程序" class="headerlink" title="5、案例1 - 无法在企业微信聊天框中启动安装包程序"></a>5、案例1 - 无法在企业微信聊天框中启动安装包程序</h3><p>企业微信默认是以标准用户运行的，比如双击桌面快捷方式或者从开始菜单中点击运行起来的，都是以标准用户权限运行的。某天我将软件最新的安装包发到企业微信的群中，同事在群中收到该文件后，<em>直接在企业微信聊天框中双击该安装包文件，但弹出了如下的报错提示框</em>：<br><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505262258375.png" alt="image.png"></p>
<p>大家平时在企业微信中收到文件后，常习惯于直接双击去查看文件或者启动程序，但此次双击却报错了。同事怀疑是我们的软件安装包有问题，询问我们是怎么回事。从这个截图看，截图的标题是个企业微信的路径，然后提示文字是：Windows 无法访问指定设备、路径或文件。你可能没有适当的权限访问该项目。</p>
<p>作为开发人员，我们这类程序运行权限的问题比较熟悉了，一看就大概知道怎么回事了。_当前的企业微信是以标准用户权限运行的，而我们的软件安装包是设置以管理员权限运行的，两个程序进程的权限不对等，所以操作失败了。_<em>低权限（标准用户权限）进程不能启动高权限（管理员权限）进程。</em></p>
<h3 id="6、案例2-使用Windbg时可能会遇到的权限不对等导致操作失败的问题"><a href="#6、案例2-使用Windbg时可能会遇到的权限不对等导致操作失败的问题" class="headerlink" title="6、案例2 - 使用Windbg时可能会遇到的权限不对等导致操作失败的问题"></a>6、案例2 - 使用Windbg时可能会遇到的权限不对等导致操作失败的问题</h3><p>我们在使用Windbg静态分析dump文件和附加到目标进程上动态调试时，也遇到过权限不对等导致操作失败的问题。</p>
<h4 id="6-1、Windbg附加到目标进程失败"><a href="#6-1、Windbg附加到目标进程失败" class="headerlink" title="6.1、Windbg附加到目标进程失败"></a>6.1、Windbg附加到目标进程失败</h4><p>当前要被附加调试的目标程序正以管理员权限运行，至于为什么以管理员权限运行，可能是右键以管理员权限运行的，也有可能程序是安装包安装后自动启动的（安装包是以管理员权限运行的，其启动的程序也继承了管理员权限）。而当前启动起来的Windbg是以标准用户权限运行（双击桌面快捷方式启动起来的），<em>当将Windbg附加到以管理员权限运行的目标程序进程上时，附加失败</em>，如下所示：<br>       <br><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505262259466.png" alt="image.png"></p>
<p><em>低权限（标准用户权限）Windbg是不能附加到高权限（管理员权限）的目标程序进程上的。</em></p>
<p>       如果Windbg是以管理员权限运行的，是可以成功附加到标准用户权限运行的进程上的，这个系统是允许的。</p>
<h4 id="6-2、dump文件拖到以管理员权限运行的Windbg中没反应"><a href="#6-2、dump文件拖到以管理员权限运行的Windbg中没反应" class="headerlink" title="6.2、dump文件拖到以管理员权限运行的Windbg中没反应"></a>6.2、dump文件拖到以管理员权限运行的Windbg中没反应</h4><p>无法用Windbg打开某个dump文件，具体现象是，<em>将磁盘上的dump文件拖入到已经打开的Windbg中没反应</em>：</p>
<p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505262259526.png" alt="image.png"></p>
<p>正常打开dump文件时的效果如下：</p>
<p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505262259862.png" alt="image.png"></p>
<p>起初怀疑是不是dump文件比较特殊，比如文件损坏了，所以打不开。按讲不应该的，dump文件的大小是非0的，估计是程序运行权限引起的。<br>经确认，<em>Windbg是右键以管理员权限运行的，而dump文件是从磁盘上拖过来的，运行在explorer文件资源管理器进程中的，而文件资源管理器是以标准用户权限运行的，<br>因为Windbg进程（管理员权限运行）与explorer.exe文件资源管理器进程（标准用户权限运行）权限不对等，所以系统禁止了文件拖放行为</em>，所以拖到Windbg中没反应。</p>
<h3 id="7、案例3-双击桌面快捷方式启动程序时并没有自动将已经启动起来的程序窗口弹出来"><a href="#7、案例3-双击桌面快捷方式启动程序时并没有自动将已经启动起来的程序窗口弹出来" class="headerlink" title="7、案例3 - 双击桌面快捷方式启动程序时并没有自动将已经启动起来的程序窗口弹出来"></a>7、案例3 - 双击桌面快捷方式启动程序时并没有自动将已经启动起来的程序窗口弹出来</h3><p>很多程序只允许启动一个程序实例（只能运行一个进程），不像浏览器程序，可以启动多个程序（窗口）。只允许程序运行一个实例，大体是这么实现的，<strong>当程序启动时会去检测是否有程序进程已经启动，如果已经有程序进程运行且不是当前的进程，则自动将当前新启动的进程退出，这样就能保证程序只运行一个实例了。</strong></p>
<p>假定当前程序已经运行且只允许运行一个程序实例，但我们没有看到程序窗口（可能程序被最小化了，或者被最小化到托盘区域了），不确定程序有没有运行起来，我们会去双击桌面快捷方式。此时，因为程序之前已经启动起来，<strong>按理我们要将已经运行的程序窗口自动弹出来</strong>。我们的软件代码也确实这么实现了，但在某个场合下还是没有将已经运行的程序窗口弹出来。</p>
<p><strong>场景是这样的</strong>：已经运行的程序，是使用安装包安装软件后自动启动起来的，因为安装包是以管理员权限运行的，所以被启动起来的程序默认是继承了管理员权限。而我们通过双击桌面快捷方式启动的新的进程是以标准权限运行的，程序初始化运行时会去检测程序是否已经运行，确实检测到程序已经运行，并找到了已经运行的程序主窗口，<em>但在调用API函数ShowWindow将该窗口Show出来时却失败了</em>。</p>
<p>       于是想到MSDN上查看API函数ShowWindow的说明，看看能不能将相关值打印出来，分析一下该函数为什么会调用失败。ShowWindow函数在MSDN上的说明如下：<br>       <br><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505262302813.png" alt="image.png"></p>
<p>该函数的返回值是BOOL型的，但_这个返回值只是标识窗口之前的状态，并不是标识ShowWindow函数是否执行成功的_，<strong>只能借助GetLastError函数，通过获取LastError值找到ShowWindow执行失败的原因</strong></p>
<blockquote>
<p>有些Windows API需要借助GetLastError获取的LastError值去判断有没有执行成功：</p>
<p>1）如果LastError值为0，则表示执行成功；</p>
<p>2）如果LastError值不为0，则表示执行失败，LastError值对应的就是执行失败的原因。</p>
</blockquote>
<p>于是添加如下的打印：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BOOL bShowTargetWndSuccess = FALSE;</span><br><span class="line"><span class="built_in">SetLastError</span>(<span class="number">0</span>);</span><br><span class="line">::<span class="built_in">ShowWindow</span>(hPrevWnd, SW_RESTORE);</span><br><span class="line">dwLastError = <span class="built_in">GetLastError</span>();</span><br><span class="line"><span class="keyword">if</span> ( dwLastError == <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 窗口Show成功了</span></span><br><span class="line">    bShowTargetWndSuccess = TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 窗口Show失败了，将API函数ShowWindow设置完后设置的LastError值打印出来</span></span><br><span class="line">    <span class="type">char</span> szLog[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(szLog, <span class="string">&quot;[CheckShowExsitingWnd] show target window failed, LastError = %d.&quot;</span>, dwLastError);</span><br><span class="line">    <span class="built_in">WriteLog</span>(szLog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后来复现了这个问题，查看到调用ShowWindow窗口Show失败时设置的LastError值为5，到VS自带的错误查看工具中查看该值的含义如下：</p>
<p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505262303350.png" alt="image.png"></p>
<p>拒绝访问，应该就是权限问题导致ShowWindow执行失败了。已经运行的程序进程因为是安装包安装完成后自动启动的，所以有管理员权限，而新启动的进程是双击桌面快捷方式启动的，所以是以标准用户权限运行的。<em>新启动的进程检测到程序已经运行，低权限（标准用户权限）的新进程想要其Show高权限（管理员权限）的已启动进程中的窗口，系统是不允许的，所以导致ShowWindow执行失败。</em></p>
<p>目前规避的办法是，当我们发现ShowWindow执行失败（判断LastError值）时，直接弹出一个提示框，但还是没有将已启动的程序窗口弹出来，这只是个规避问题的方法，用户体验不好。</p>
<p>最好的解决办法是，安装包在安装完成后自动启动进程时，直接以标准用户权限启动程序，这样就没有权限不对等的问题了，这样就能自动弹出已经运行的程序窗口了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/14/debug/debug%20windbg%20information/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gcmz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gcmz Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Gcmz Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/14/debug/debug%20windbg%20information/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-05-14 19:48:44 / 修改时间：19:51:08" itemprop="dateCreated datePublished" datetime="2025-05-14T19:48:44+08:00">2025-05-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="windbg"><a href="#windbg" class="headerlink" title="windbg"></a>windbg</h2><h3 id="pdb"><a href="#pdb" class="headerlink" title="pdb"></a>pdb</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">!sym noisy</span><br><span class="line">!sym quiet</span><br><span class="line"></span><br><span class="line">D:\Environment\Symbols;SRV*D:\Environment\Symbols*http://msdl.microsoft.com/download/symbols;E:\Develop\Project;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="分离进程"><a href="#分离进程" class="headerlink" title="分离进程"></a>分离进程</h3><blockquote>
<p> 注意:如果是windbg附加到应用层，如果不进行分离，直接关闭windbg，会导致被附加的进程死亡</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.detach</span><br><span class="line">qd</span><br></pre></td></tr></table></figure>


<h3 id="转储"><a href="#转储" class="headerlink" title="转储"></a>转储</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.dump</span><br></pre></td></tr></table></figure>


<h3 id="windbg-控制日志输出"><a href="#windbg-控制日志输出" class="headerlink" title="windbg 控制日志输出"></a>windbg 控制日志输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eb nt!Kd_DEFAULT_Mask 0</span><br><span class="line">eb nt!Kd_DEFAULT_Mask 0xf</span><br></pre></td></tr></table></figure>

<blockquote>
<p>下面 eb 直接将DbgPrint函数返回</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eb DbgPrint 0xc3; </span><br><span class="line">eb DbgPrintEx 0xc3; </span><br><span class="line">ed nt!Kd_FUSION_Mask 0; </span><br><span class="line">ed nt!Kd_SXS_Mask 0; </span><br><span class="line">ed nt!Kd_WIN2000_Mask 0;</span><br></pre></td></tr></table></figure>


<h3 id="进程线程"><a href="#进程线程" class="headerlink" title="进程线程"></a>进程线程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">!process 0 0</span><br><span class="line"></span><br><span class="line">## dump 所有</span><br><span class="line">!process 0 1f  </span><br><span class="line"></span><br><span class="line">## 通过程序名获取</span><br><span class="line">!process 0 0 &lt;xxx.exe&gt;</span><br><span class="line"></span><br><span class="line">!process ffffde06b43d04c0 1f</span><br><span class="line">!object  ffffde06b43d04c0</span><br><span class="line"></span><br><span class="line">## 正在运行的线程,查死锁卡死问题</span><br><span class="line">!running it </span><br><span class="line">!thread &lt;&gt;</span><br><span class="line"></span><br><span class="line">## 切换到目标进程/线程空间</span><br><span class="line">.process &lt;&gt;</span><br><span class="line">.thread &lt;&gt;</span><br><span class="line"></span><br><span class="line">## 查看当前进程/线程</span><br><span class="line">.process</span><br><span class="line">.thread</span><br><span class="line"></span><br><span class="line">## 获取线程的堆栈范围</span><br><span class="line">dt _KTHREAD ffffa68d9a78e080</span><br><span class="line">+0x030 StackLimit</span><br><span class="line">+0x038 StackBase</span><br><span class="line">dsp StackLimit StackBase</span><br><span class="line"></span><br><span class="line">## 可以查看一个线程的调用栈</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~* k</span><br></pre></td></tr></table></figure>



<h3 id="Apc"><a href="#Apc" class="headerlink" title="Apc"></a>Apc</h3><blockquote>
<p>这里需要进行补充</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!apc</span><br><span class="line">    !apc proc Process</span><br><span class="line">    !apc thre Thread</span><br><span class="line">    !apc KAPC</span><br></pre></td></tr></table></figure>


<h3 id="IRP"><a href="#IRP" class="headerlink" title="IRP"></a>IRP</h3><p>在!process &lt;&gt; 1f 的过程中，如果有进程还有未处理完的irp，会出现一下的日志打印</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IRP List:</span><br><span class="line">            ffffde0371c7b010: (0006,0478) Flags: 00060000  Mdl: 00000000</span><br><span class="line">            ffffde036fd6ba20: (0006,0478) Flags: 00060000  Mdl: 00000000</span><br><span class="line">            ffffde03727efb20: (0006,0478) Flags: 00060000  Mdl: 00000000</span><br></pre></td></tr></table></figure>

<p>以上信息中 ffffde0371c7b010 为 IRP 指针，通过 <code>!irp &lt;address&gt;</code> 命令可以查看当前irp 的详细信息，例如以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[IRP_MJ_DIRECTORY_CONTROL(c), N/A(2)]</span><br><span class="line">     0  1 ffffde036c5ad030 ffffde0374e5adf0 00000000-00000000    pending</span><br><span class="line">        \FileSystem\Ntfs</span><br><span class="line">        Args: 00000800 00000015 00000000 00000000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中第二点：<br><code>ffffde0374e5adf0</code>: FileObject 地址</p>
<p>通过  <code>dt _FILE_OBJECT ffffde0374e5adf0</code>  进行查看</p>
<h3 id="handle"><a href="#handle" class="headerlink" title="handle"></a>handle</h3><p>!htrace -enable：启用handle trace,并且创建第一个快照作为初始状态，方便使用 -diff选项<br>!htrace：显示当前的所有句柄信息<br>!htrace -snapshot：创建快照，用作-diff选项<br>!handle xxx f：查看一下handle的信息</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/14/debug/%E4%BE%8B%E5%AD%90/windbg%20%E8%A7%82%E5%AF%9F%E5%8F%A5%E6%9F%84%E6%B3%84%E9%9C%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gcmz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gcmz Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Gcmz Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/14/debug/%E4%BE%8B%E5%AD%90/windbg%20%E8%A7%82%E5%AF%9F%E5%8F%A5%E6%9F%84%E6%B3%84%E9%9C%B2/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-14 19:06:11" itemprop="dateCreated datePublished" datetime="2025-05-14T19:06:11+08:00">2025-05-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-08 23:23:11" itemprop="dateModified" datetime="2025-06-08T23:23:11+08:00">2025-06-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="一、观察进程是否有句柄泄漏"><a href="#一、观察进程是否有句柄泄漏" class="headerlink" title="一、观察进程是否有句柄泄漏"></a>一、观察进程是否有句柄泄漏</h3><h4 id="1、查看工具"><a href="#1、查看工具" class="headerlink" title="1、查看工具"></a>1、查看工具</h4><p>使用<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8&spm=1001.2101.3001.7020">任务管理器</a>或Process Explorer（procexp.exe）工具可观察进程的句柄数。</p>
<h5 id="任务管理器查看句柄数"><a href="#任务管理器查看句柄数" class="headerlink" title="任务管理器查看句柄数"></a>任务管理器查看句柄数</h5><p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505142010412.png" alt="image.png|600"></p>
<p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505142011038.png" alt="image.png"></p>
<h5 id="procexp-exe查看进程句柄信息"><a href="#procexp-exe查看进程句柄信息" class="headerlink" title="procexp.exe查看进程句柄信息"></a>procexp.exe查看进程句柄信息</h5><h5 id=""><a href="#" class="headerlink" title=""></a><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505142011701.png" alt="image.png"></h5><p>2、判断是否有句柄泄漏<br>通常在程序运行稳定后，再观察句柄数有无增长，比如进程启动5分钟后再开始观察，让其运行半天或一天，比较前后的句柄数有无明显增长。</p>
<p>可以使用性能监视工具或者在Procexp.exe选中进程，点击菜单中的保存可以存成txt文本查看，可以通过比较前后两次的txt查看哪些句柄有泄漏。</p>
<h3 id="二、定位方法"><a href="#二、定位方法" class="headerlink" title="二、定位方法"></a>二、定位方法</h3><h4 id="1、WinDbg分析句柄泄漏"><a href="#1、WinDbg分析句柄泄漏" class="headerlink" title="1、WinDbg分析句柄泄漏"></a>1、WinDbg分析句柄泄漏</h4><h5 id="1-1-Event句柄泄漏"><a href="#1-1-Event句柄泄漏" class="headerlink" title="1.1 Event句柄泄漏"></a>1.1 Event句柄泄漏</h5><h6 id="1-1-1-代码示例"><a href="#1-1-1-代码示例" class="headerlink" title="1.1.1 代码示例"></a>1.1.1 代码示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">// 故意制造句柄泄漏</span><br><span class="line">void HandleLeak()</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        HANDLE hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);</span><br><span class="line">        if (hEvent == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;Failed to create event. Error code: %lu\n&quot;, GetLastError());</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;Created event handle #%d: 0x%p\n&quot;, i + 1, hEvent);</span><br><span class="line">        Sleep(10000);  // 每10秒创建一个新的事件对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    HandleLeak();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成文件名为testC.exe</p>
<h5 id="1-1-2-windbg-分析"><a href="#1-1-2-windbg-分析" class="headerlink" title="1.1.2 windbg 分析"></a>1.1.2 windbg 分析</h5><p>1）打开WinDbg，设置好pdb路径以及源码路径<br><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505142011337.png"></p>
<p>2）打开exe</p>
<p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505142011714.png" alt="image.png"></p>
<p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505142017730.png" alt="image-20250514201702704"></p>
<p>3）在WinDbg命令窗口中执行g<br><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505142016924.png" alt="image-20250514201650877"></p>
<p>4）过一会后，点击WinDbg菜单栏的Break或者按下Ctrl+Break<br><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505142011259.png" alt="image.png"></p>
<p>5）此时分别执行以下命令<br>!htrace -enable：启用handle trace,并且创建第一个快照作为初始状态，方便使用 -diff选项<br>!htrace：显示当前的所有句柄信息<br>!htrace -snapshot：创建快照，用作-diff选项</p>
<p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505142011425.png" alt="image.png"></p>
<p>此时相当于已经创建了一个句柄信息快照，随后执行一下g命令，继续运行，同3）</p>
<p>6） 运行一段时间后，break掉，同4），在WinDbg命令窗口执行<br>!htrace -diff：使用当前状态的信息，和最近一次的快照信息做对比</p>
<p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505142016594.png" alt="image-20250514201638564"></p>
<p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505142016810.png" alt="image-20250514201628783"></p>
<p>由图可知，和快照做对比，发现比快照多了7个handle</p>
<p>7）根据6）中的handle值，执行<br>!handle xxx f：查看一下handle的信息</p>
<p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505142016075.png" alt="image-20250514201616038"></p>
<p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505142012991.png" alt="image.png"></p>
<p>从这里可以知道这个handle的类型是event （但是其实从process那一步就可以看到句柄的类型了）</p>
<p>8）在有源码和pdb的情况下，可以使用 lsa命令定位到源码所在位置，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsa KERNELBASE!CreateEventExW+0x0000000000000056</span><br></pre></td></tr></table></figure>
<p>当然这里因为是windows内部的模块，没有加pdb和源码，因此不会显示到对应行</p>
<p>9）根据7），我们看不见是我们那一行代码导致的问题，因此可以反汇编获取函数的返回地址，如下：</p>
<p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505142015647.png" alt="image-20250514201546604"></p>
<p>我们找到返回地址，图中箭头位置，拿到7713a02a，输入如下命令</p>
<p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505142016882.png" alt="image-20250514201602829"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.logappend /u e:/test.log：表示将此命令的结果Append到e:/test.log文件中，/u表示 in Unicode format。</span><br><span class="line">k ：表示输出栈信息</span><br><span class="line">r eax：表示输出eax寄存器的值，即取函数的返回值</span><br><span class="line">.logclose：表示关闭日志记录                             </span><br><span class="line">g：表示命中断点后继续执行</span><br></pre></td></tr></table></figure>

<p>也可以直接 bp 然后一个一个看<br><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505142023460.png" alt="image.png"></p>
<p>11）打开test.log</p>
<p><img src="https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505142015563.png" alt="image-20250514201533513"></p>
<p>由日志去查看源代码，发现CreateEvent后没有close的操作，到此就定位出了Event句柄泄漏的位置。</p>
<p>备注：当我们从文件得知可能出现句柄泄漏的句柄时，我们可以用windbg挂对应的进程，等对应的进程或目录或其他名称出现，这个时候用procexp看对应句柄值，再在windbg执行!htrace -diff的内容中查找对应的句柄值。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/22/linux/liunx%20%E7%BC%96%E8%AF%91%E5%91%8A%E8%AD%A6%E9%80%9F%E6%9F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gcmz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gcmz Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Gcmz Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/22/linux/liunx%20%E7%BC%96%E8%AF%91%E5%91%8A%E8%AD%A6%E9%80%9F%E6%9F%A5/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-04-22 16:17:41 / 修改时间：17:28:08" itemprop="dateCreated datePublished" datetime="2025-04-22T16:17:41+08:00">2025-04-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>1.多级宏定义可以加 <code>error</code></p>
<blockquote>
<p>使用多级宏判断时，判断进入哪一分支，可以在编码中加入  <code>error</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#ifdef __x86__</span><br><span class="line">    // x86 处理</span><br><span class="line">#elif defined(__arm__)</span><br><span class="line">    // ARM 处理</span><br><span class="line">    #error &quot;Unsupported architecture. Please define a valid arch macro.&quot;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/22/linux/linux%20CONTAINING_RECORD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gcmz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gcmz Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Gcmz Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/22/linux/linux%20CONTAINING_RECORD/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-04-22 15:37:04 / 修改时间：16:17:30" itemprop="dateCreated datePublished" datetime="2025-04-22T15:37:04+08:00">2025-04-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在 C 语言开发中，尤其是驱动开发和内核级编程中，我们常常需要从结构体的某个成员指针，反推整个结构体的起始地址。这在实现内核链表（如 Windows 内核的 LIST_ENTRY）、对象封装或回调系统中尤为常见。实现这一需求的核心技巧就是使用 <code>CONTAINING_RECORD</code> 宏，它的实现背后，正是 <code>&amp;((type*)0)-&gt;member</code> 这样的偏移量计算技巧。</p>
<h2 id="一、CONTAINING-RECORD-是什么？"><a href="#一、CONTAINING-RECORD-是什么？" class="headerlink" title="一、CONTAINING_RECORD 是什么？"></a>一、CONTAINING_RECORD 是什么？</h2><p><code>CONTAINING_RECORD</code> 是一个宏，它的定义如下（常见版本）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONTAINING_RECORD(address, type, field) \</span></span><br><span class="line"><span class="meta">    ((type *)((char *)(address) - (size_t)&amp;(((type *)0)-&gt;field)))</span></span><br></pre></td></tr></table></figure>

<p>它的作用是：</p>
<blockquote>
<p>已知结构体 <code>type</code> 中 <code>field</code> 成员的地址为 <code>address</code>，反推出结构体 <code>type</code> 的起始地址。</p>
</blockquote>
<h2 id="二、宏拆解分析"><a href="#二、宏拆解分析" class="headerlink" title="二、宏拆解分析"></a>二、宏拆解分析</h2><p>我们来逐步拆解这个宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">char</span> *)(address)</span><br></pre></td></tr></table></figure>

<ul>
<li>将成员地址强制转换为 <code>char*</code> 类型是为了方便做字节级的指针运算。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">size_t</span>)&amp;(((type *)<span class="number">0</span>)-&gt;field)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这部分是计算 <code>field</code> 成员在 <code>type</code> 结构体中的偏移量。</p>
</li>
<li><p>通过将 0 强制转换为 <code>type*</code> 指针，访问它的 <code>field</code> 成员，再取地址，就可以得到 <code>field</code> 相对于结构体起始地址的偏移（以字节为单位）。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="type">char</span> *)(address) - 偏移量)</span><br></pre></td></tr></table></figure>

<ul>
<li>从成员地址中减去偏移量，就得到了结构体首地址。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((type *)...)</span><br></pre></td></tr></table></figure>

<ul>
<li>最后，将结果强制转换为结构体指针类型。</li>
</ul>
<h2 id="三、实际例子"><a href="#三、实际例子" class="headerlink" title="三、实际例子"></a>三、实际例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MY_STRUCT</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125; MY_STRUCT;</span><br><span class="line"></span><br><span class="line">MY_STRUCT s = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"><span class="type">int</span> *pb = &amp;s.b;</span><br><span class="line"></span><br><span class="line">MY_STRUCT *ps = CONTAINING_RECORD(pb, MY_STRUCT, b);</span><br></pre></td></tr></table></figure>

<p>展开后就是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps = (MY_STRUCT *)((<span class="type">char</span> *)pb - offsetof(MY_STRUCT, b));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>你会发现，<code>CONTAINING_RECORD</code> 其实和 <code>offsetof</code> 的本质是一致的，都是基于成员偏移量计算结构体地址。</p>
</blockquote>
<h2 id="四、应用场景"><a href="#四、应用场景" class="headerlink" title="四、应用场景"></a>四、应用场景</h2><p>这个宏在实际开发中的用途非常广泛，以下是常见场景：</p>
<h3 id="1-内核链表结构"><a href="#1-内核链表结构" class="headerlink" title="1. 内核链表结构"></a>1. 内核链表结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE</span> &#123;</span></span><br><span class="line">    LIST_ENTRY List;</span><br><span class="line">    <span class="type">int</span> DeviceId;</span><br><span class="line">&#125; DEVICE;</span><br><span class="line"></span><br><span class="line">DEVICE *dev = CONTAINING_RECORD(pListEntry, DEVICE, List);</span><br></pre></td></tr></table></figure>

<h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p><code>CONTAINING_RECORD</code> 的核心思想是：</p>
<blockquote>
<p><strong>结构体指针 &#x3D; 成员指针 - 成员偏移量</strong></p>
</blockquote>
<p>它看起来有点黑魔法，但实际是一种非常高效、零开销的做法，用好了能写出非常优雅的底层代码。</p>
<p>这个技巧背后最根本的就是 <code>&amp;((type *)0)-&gt;member</code>，建议你深入理解这个表达式背后的含义和使用方式，它不仅对理解 <code>CONTAINING_RECORD</code> 有帮助，更是很多底层 C 语言技巧的基础。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Gcmz</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
